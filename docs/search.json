[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "R Practicals for NST Part III Systems Biology",
    "section": "",
    "text": "Practicals\nAs part of the NST Part III Systems Biology subject we will be learning R programming and foundation data visualisation and manipulation techniques that are useful not just for this course but also beyond. These core concepts are used and applied throughout the Systems Biology course. Understanding these are key to be able to follow the rest of the course.\n\nEarn your badge each week\nIn the programming world, many organisations award badges to learners on the acquisition of a new skill or completion of a milestone. If you attempted and solved all the exercises of each practical, you will earn a badge. By the end of week four you will have earned the 4-star badge  that marks the end of the Systems Biology R practicals.\nBelow are the links of each practical sheet that we will be working on each week.\n\n\n\nPractical 1\nPractical 2\nPractical 3\nPractical 4\n\n\n\n\n\n\n\n\n\n\nGo to Practical 1 →\nGo to Practical 2 →\nActivated after Practical 2\nActivated after Practical 3"
  },
  {
    "objectID": "practical1.html",
    "href": "practical1.html",
    "title": "Practical 1",
    "section": "",
    "text": "Getting started with R programming"
  },
  {
    "objectID": "practical1.html#aim",
    "href": "practical1.html#aim",
    "title": "Practical 1",
    "section": "Aim",
    "text": "Aim\nThe aim of this practical is to learn the R programming language syntax and its core programming concepts and how to use them. It is the first step in learning R programming."
  },
  {
    "objectID": "practical1.html#objectives",
    "href": "practical1.html#objectives",
    "title": "Practical 1",
    "section": "Objectives",
    "text": "Objectives\nDuring this practical you will learn how to:\n\ncreate a project and an R program in RStudio\ndefine variables\nuse different data types in R\nuse different data structures in Python and perform different operations with them\nhow to call functions\nhow to find help"
  },
  {
    "objectID": "practical1.html#instructions",
    "href": "practical1.html#instructions",
    "title": "Practical 1",
    "section": "Instructions",
    "text": "Instructions\nThe best way to do this practical is to read the Practical Notes which will introduce you to the core concepts of R programming. These notes are designed with all the details you would need to be able to perform the exercises in this practical. In general, you would not need to refer to additional texts and resources as these notes have been explained in detail. Apart from the exercises listed below, there are also examples throughout the notes which provide insight on the concepts introduced, and therefore, it is recommended that you also run these examples as you progress through the practical notes.\nIf you are an experienced R programmer, you might find that you already know about the content in these notes. You may want to skip sections of notes that you already know and attempt the exercises that are at the higher levels.\n\nExercises levels\nExercises in this practical are labelled with the level of difficulty of the respective exercise:\n\n\n\n\n\n\n\nLevel\nDescription\n\n\n\n\n\nLevel 1: Exercises in Level 1 are simple exercises designed to get you familiar with the R syntax. If you already know how to program in R, you may skip these exercises.\n\n\n\nLevel 2: Exercises in Level 2 combine different R programming concepts to solve simple problems.\n\n\n\nLevel 3: Exercises in Level 3 solve more complex problems.\n\n\n\n\n\nExercises\nThis practical is composed of the following exercises:\n\n\n\nExercise\nDescription\nLevel\n\n\n\n\nExercise 1\nVariables: In this exercise we assign different values to variables\n\n\n\nExercise 2\nVectors: This exercise introduces vector operations.\n\n\n\nExercise 3\nMissing data: In this exercise we will look on how to tackle missing data.\n\n\n\nExercise 4\nData frame: In this exercise we explore the different attributes of a data frame.\n\n\n\nExercise 5\nData frame indexing: In this exercise we will index dataframe in different ways.\n\n\n\nExercise 6\nFactors: This exercise we will look at categorical data.\n\n\n\n\n\n\n\n\n\n\nManaged to solve all the exercises? First badge earned!\n\n\n\n In the programming world, many organisations award badges to learners on the acquisition of a new skill or completion of a milestone. If you attempted and solved all the exercises of this practical, you definitely deserve your first R badge of this course."
  },
  {
    "objectID": "getting-started.html#what-is-r",
    "href": "getting-started.html#what-is-r",
    "title": "1  Getting Started in R",
    "section": "1.1 What is R?",
    "text": "1.1 What is R?\nR is a statistical programming language. It is very popular in the Data Science field, including Bioinformatics. The term “R” is used to refer to both the programming language and the software that interprets the scripts written using it."
  },
  {
    "objectID": "getting-started.html#why-learn-r",
    "href": "getting-started.html#why-learn-r",
    "title": "1  Getting Started in R",
    "section": "1.2 Why learn R?",
    "text": "1.2 Why learn R?\nR does not involve lots of pointing and clicking\nThe learning curve might be steeper than with other software, but with R, the results of your analysis do not rely on remembering a succession of pointing and clicking, but instead on a series of written commands, and that’s a good thing! So, if you want to redo your analysis because you collected more data, you don’t have to remember which button you clicked in which order to obtain your results; you just have to run your script again.\nWorking with scripts makes the steps you used in your analysis clear, and the code you write can be inspected by someone else who can give you feedback and spot mistakes.\nWorking with scripts forces you to have a deeper understanding of what you are doing, and facilitates your learning and comprehension of the methods you use.\n\nR code is great for reproducibility\nReproducibility is when someone else (including your future self) can obtain the same results from the same dataset when using the same analysis.\nR integrates with other tools to generate reports from your code. If you collect more data, or fix a mistake in your dataset, the figures and the statistical tests in your manuscript are updated automatically after running the code again.\nAn increasing number of journals and funding agencies expect analyses to be reproducible, so knowing R will give you an edge with these requirements.\n\n\nR is interdisciplinary and extensibe\nWith 10,000+ packages that can be installed to extend its capabilities, R provides a framework that allows you to combine statistical approaches from many scientific disciplines to best suit the analytical framework you need to analyze your data. For instance, R has packages for image analysis, GIS, time series, population genetics, and a lot more.\n\n\nR works on data of different sizes\nThe skills you learn with R scale easily with the size of your dataset. Whether your dataset has hundreds or millions of lines, it won’t make much difference to you.\nR is designed for data analysis. It comes with special data structures and data types that make handling of missing data and statistical factors convenient.\nR can connect to spreadsheets, databases, and many other data formats, on your computer or on the web.\n\n\nR produces high-quality graphics\nThe plotting functionalities in R are endless, and allow you to adjust any aspect of your graph to convey most effectively the message from your data.\n\n\nR has a large and welcoming community\nThousands of people use R daily. Many of them are willing to help you through mailing lists and websites such as Stack Overflow, or on the RStudio community.\n\n\nNot only is R free, but it is also open-source and cross-platform\nAnyone can inspect the source code to see how R works. Because of this transparency, there is less chance for mistakes, and if you (or someone else) find some, you can report and fix bugs."
  },
  {
    "objectID": "getting-started.html#introduction-to-rstudio",
    "href": "getting-started.html#introduction-to-rstudio",
    "title": "1  Getting Started in R",
    "section": "1.3 Introduction to RStudio?",
    "text": "1.3 Introduction to RStudio?\nRStudio is currently a very popular Integrated Development Environment (IDE) for working with R. An IDE is an application used by software developers that facilitates programming by offering source code editing, building and debugging tools all integrated into one application. To function correctly, RStudio needs R and therefore both need to be installed on your computer.\nThe RStudio Desktop open-source product is free under the Affero General Public License (AGPL) v3. Other versions of RStudio are also available.\nWe will use RStudio IDE to write code, navigate the files on our computer, inspect the variables we are going to create, and visualize the plots we will generate. RStudio can also be used for other things (e.g., version control, developing packages, writing Shiny apps) that we will not cover during this course.\n\n\n\nFigure 1.1: RStudio interface screenshot. Clockwise from top left: Source, Environment/History, Files/Plots/Packages/Help/Viewer, Console.\n\n\nRStudio is divided into 4 panes: the Source for your scripts and documents (top-left, in the default layout), your Environment/History (top-right), your Files/Plots/Packages/Help/Viewer (bottom-right), and the R Console (bottom-left). The placement of these panes and their content can be customized (see menu, Tools -&gt; Global Options -&gt; Pane Layout).\nOne of the advantages of using RStudio is that all the information you need to write code is available in a single window. Additionally, with many shortcuts, auto completion, and highlighting for the major file types you use while coding in R, RStudio will make typing easier and less error-prone.\n\n1.3.1 Creating a Project in RStudio\nBefore writing code in R, we need to create an R Project in RStudio. An R project is a workspace where you can keep all the files and settings associated with a project together. In that way, the next time you open the R Project it would be easier to resume work from where you left it.\n\n\n\n\n\n\nTo create an R Project:\n\nStart RStudio.\nUnder the File menu, click on New Project. Choose New Directory, then New Project.\nEnter a name for this new folder (or directory), and choose a convenient location for it. This will be your working directory for the rest of the day (e.g., ~/my-first-project).\nClick on Create Project.\n(Optional) Set Preferences to Never save workspace in RStudio.\n\nRStudio’s default preferences generally work well, but saving a workspace to .RData can be cumbersome, especially if you are working with larger datasets as this would save all the data that is loaded into R into the .RData file. To turn that off, go to Tools –&gt; Global Options and select the Never option for Save workspace to .RData' on exit as shown in Figure 1.2.\n\n\n\nFigure 1.2: Set ‘Save workspace to .RData on exit’ to ‘Never’\n\n\n\n\n\n\n\n1.3.2 Working directory\nWhenever we are working on a project, it is good practice to keep a set of related data, analyses, and text self-contained in a single folder, called the working directory.\nUsing a consistent folder structure across your projects will help keep things organized, and will also make it easy to find things in the future. This can be especially helpful when you have multiple projects. In general, you may create directories (folders) for scripts, data, and documents.\n\ndata/ Use this folder to store your raw data. For the sake of transparency and provenance, you should always keep a copy of your raw data accessible and do as much of your data cleanup and preprocessing programmatically (i.e., with scripts, rather than manually). Separating raw data from processed data is also a good idea. For example, you could have files data/raw/survey.plot1.txt and data/raw/survey.plot2.txt kept separate from a data_output/survey.csv file generated by the scripts/01.preprocess.survey.R script.\ndocuments/ This would be a place to keep documentation and other text documents\nscripts/ This would be the location to keep your R scripts for different analyses or plotting.\n\nYou may want additional directories or subdirectories depending on your project needs, but these should form the backbone of your working directory.\n\n\n\nFigure 1.3: Example of a working directory structure.\n\n\nFor this workshop, we will need a data/ folder to store our raw data, and we will use data_output/ for when we learn how to export data as CSV files, and fig_output/ folder for the figures that we will save.\n\n\n\n\n\n\nUnder the Files tab on the right of the screen, click on New Folder and create a folder named data within your newly created working directory (e.g., ~/my-first-project/data). Repeat these operations to create a data_output/ and a fig_output folders.\n\n\n\nWe are going to keep the script in the root of our working directory because we are only going to use one file and it will make things easier.\nYour working directory should now look like this:\n\n\n\nFigure 1.4: Working Directory in RStudio.\n\n\nThe working directory is an important concept to understand. It is the place from where R will be looking for and saving the files to. When you write code for your project, it should refer to files in relation to the root of your working directory.\nAll of the scripts within this folder can then use relative paths to files in the working directory that indicate where inside the project a file is located (as opposed to absolute paths, which point to where a file is on a specific computer). Working this way makes it a lot easier to move your project around on your computer and share it with others without worrying about whether or not the underlying scripts will still work.\n\nAbsolute vs Relative paths examples\nRelative path: data/dataset1.txt\nAbsolute path: C:/Users/User1/Documents/R/my-first-project/data/dataset1.txt\n\nUsing RStudio projects makes it easy to organise your files in the project and ensures that your working directory is set properly. RStudio shows your current working directory at the top of your window:\n\nAnother way to check your working directory is by typing getwd() in the console pane. If for some reason your working directory is not what it should be, you can change it in the RStudio interface by navigating in the file browser where your working directory should be, and clicking on the blue gear icon “More”, and select “Set As Working Directory”. Alternatively you can use setwd(\"/path/to/working/directory\") to reset your working directory (not recommended). However, your scripts should not include this line because it will fail on someone else’s computer."
  },
  {
    "objectID": "getting-started.html#interacting-with-r",
    "href": "getting-started.html#interacting-with-r",
    "title": "1  Getting Started in R",
    "section": "1.4 Interacting with R",
    "text": "1.4 Interacting with R\nThe basis of programming is that we write down instructions for the computer to follow, and then we tell the computer to follow those instructions. We write, or code, instructions in R because it is a common language that both the computer and we can understand. We call the instructions commands and we tell the computer to follow the instructions by executing (also called running) those commands.\nThere are two main ways of interacting with R: by using the console or by using script files (plain text files that contain your code). The console pane (in RStudio, the bottom left panel) is the place where commands written in the R language can be typed and executed immediately by the computer. It is also where the results will be shown for commands that have been executed. You can type commands directly into the console and press Enter to execute those commands, but they will be forgotten when you close the session.\nBecause we want our code and workflow to be reproducible, it is better to type the commands we want in the script editor, and save the script. This way, there is a complete record of what we did, and anyone (including our future selves!) can easily replicate the results on their computer.\nRStudio allows you to execute commands directly from the script editor by using the Ctrl + Enter shortcut (on Macs, Cmd + Return will work, too). The command on the current line in the script (indicated by the cursor) or all of the commands in the currently selected text will be sent to the console and executed when you press Ctrl + Enter. You can find other keyboard shortcuts in this RStudio cheatsheet about the RStudio IDE.\nAt some point in your analysis you may want to check the content of a variable or the structure of an object, without necessarily keeping a record of it in your script. You can type these commands and execute them directly in the console. RStudio provides the Ctrl + 1 and Ctrl + 2 shortcuts allow you to jump between the script and the console panes.\nIf R is ready to accept commands, the R console shows a &gt; prompt. If it receives a command (by typing, copy-pasting or sent from the script editor using Ctrl + Enter), R will try to execute it, and when ready, will show the results and come back with a new &gt; prompt to wait for new commands.\nIf R is still waiting for you to enter more data because it isn’t complete yet, the console will show a + prompt. It means that you haven’t finished entering a complete command. This is because you have not ‘closed’ a parenthesis or quotation, i.e. you don’t have the same number of left-parentheses as right-parentheses, or the same number of opening and closing quotation marks. When this happens, and you thought you finished typing your command, click inside the console window and press Esc; this will cancel the incomplete command and return you to the &gt; prompt."
  },
  {
    "objectID": "getting-started.html#what-happens-after-the-course",
    "href": "getting-started.html#what-happens-after-the-course",
    "title": "1  Getting Started in R",
    "section": "1.5 What happens after the course?",
    "text": "1.5 What happens after the course?\nThe material we cover during this course will give you an initial taste of how you can use R to analyze data for your own research. However, you will need to learn more to do advanced operations such as cleaning your dataset, using statistical methods, or creating beautiful graphics. The best way to become proficient and efficient at R, as with any other tool, is to use it to address your actual research questions. As a beginner, it can feel daunting to have to write a script from scratch, and given that many people make their code available online, modifying existing code to suit your purpose might make it easier for you to get started."
  },
  {
    "objectID": "getting-started.html#seeking-help",
    "href": "getting-started.html#seeking-help",
    "title": "1  Getting Started in R",
    "section": "1.6 Seeking help",
    "text": "1.6 Seeking help\n\nUse the built-in RStudio help interface to search for more information on R functions\n\n\n\nFigure 1.5: RStudio help interface.\n\n\nOne of the fastest ways to get help, is to use the RStudio help interface. This panel by default can be found at the lower right hand panel of RStudio. As seen in the screenshot, by typing the word “Mean”, RStudio tries to also give a number of suggestions that you might be interested in. The description is then shown in the display window.\n\n\nI know the name of the function I want to use, but I’m not sure how to use it\nIf you need help with a specific function, let’s say barplot(), you can type:\n\n?barplot\n\nIf you just need to remind yourself of the names of the arguments, you can use:\n\nargs(lm)\n\n\n\nI want to use a function that does X, there must be a function for it but I don’t know which one…\nIf you are looking for a function to do a particular task, you can use the help.search() function, which is called by the double question mark ??. However, this only looks through the installed packages for help pages with a match to your search request\n\n??kruskal\n\nIf you can’t find what you are looking for, you can use the rdocumentation.org website that searches through the help files across all packages available.\nFinally, a generic Google or internet search “R &lt;task&gt;” will often either send you to the appropriate package documentation or a helpful forum where someone else has already asked your question.\n\n\nI am stuck… I get an error message that I don’t understand\nStart by googling the error message. However, this doesn’t always work very well because often, package developers rely on the error catching provided by R. You end up with general error messages that might not be very helpful to diagnose a problem (e.g. “subscript out of bounds”). If the message is very generic, you might also include the name of the function or package you’re using in your query.\nHowever, you should check Stack Overflow. Search using the [r] tag. Most questions have already been answered, but the challenge is to use the right words in the search to find the answers: http://stackoverflow.com/questions/tagged/r\nThe Introduction to R can also be dense for people with little programming experience but it is a good place to understand the underpinnings of the R language.\nThe R FAQ is dense and technical but it is full of useful information.\n\n\nAsking for help\nThe key to receiving help from someone is for them to rapidly grasp your problem. You should make it as easy as possible to pinpoint where the issue might be.\nTry to use the correct words to describe your problem. For instance, a package is not the same thing as a library. Most people will understand what you meant, but others have really strong feelings about the difference in meaning. The key point is that it can make things confusing for people trying to help you. Be as precise as possible when describing your problem.\nIf possible, try to reduce what doesn’t work to a simple reproducible example. If you can reproduce the problem using a very small data frame instead of your 50,000 rows and 10,000 columns one, provide the small one with the description of your problem. When appropriate, try to generalize what you are doing so even people who are not in your field can understand the question. For instance instead of using a subset of your real dataset, create a small (3 columns, 5 rows) generic one. For more information on how to write a reproducible example see this article by Hadley Wickham.\nTo share an object with someone else, if it’s relatively small, you can use the function dput(). It will output R code that can be used to recreate the exact same object as the one in memory:\n\ndput(head(iris)) # iris is an example data frame that comes with R and head() is a function that returns the first part of the data frame\n\nstructure(list(Sepal.Length = c(5.1, 4.9, 4.7, 4.6, 5, 5.4), \n    Sepal.Width = c(3.5, 3, 3.2, 3.1, 3.6, 3.9), Petal.Length = c(1.4, \n    1.4, 1.3, 1.5, 1.4, 1.7), Petal.Width = c(0.2, 0.2, 0.2, \n    0.2, 0.2, 0.4), Species = structure(c(1L, 1L, 1L, 1L, 1L, \n    1L), levels = c(\"setosa\", \"versicolor\", \"virginica\"), class = \"factor\")), row.names = c(NA, \n6L), class = \"data.frame\")\n\n\nIf the object is larger, provide either the raw file (i.e., your CSV file) with your script up to the point of the error (and after removing everything that is not relevant to your issue). Alternatively, in particular if your question is not related to a data frame, you can save any R object to a file:\n\nsaveRDS(iris, file=\"/tmp/iris.rds\")\n\nThe content of this file is however not human readable and cannot be posted directly on Stack Overflow. Instead, it can be sent to someone by email who can read it with the readRDS() command (here it is assumed that the downloaded file is in a Downloads folder in the user’s home directory):\n\nsome_data &lt;- readRDS(file=\"~/Downloads/iris.rds\")\n\nLast, but certainly not least, always include the output of sessionInfo() as it provides critical information about your platform, the versions of R and the packages that you are using, and other information that can be very helpful to understand your problem.\n\nsessionInfo()\n\nR version 4.2.2 (2022-10-31)\nPlatform: aarch64-apple-darwin20 (64-bit)\nRunning under: macOS Ventura 13.3\n\nMatrix products: default\nBLAS:   /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRblas.0.dylib\nLAPACK: /Library/Frameworks/R.framework/Versions/4.2-arm64/Resources/lib/libRlapack.dylib\n\nlocale:\n[1] en_US.UTF-8/en_US.UTF-8/en_US.UTF-8/C/en_US.UTF-8/en_US.UTF-8\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] compiler_4.2.2  magrittr_2.0.3  fastmap_1.1.0   cli_3.4.1      \n [5] tools_4.2.2     htmltools_0.5.3 rstudioapi_0.14 yaml_2.3.6     \n [9] stringi_1.7.8   rmarkdown_2.18  knitr_1.41      stringr_1.4.1  \n[13] jsonlite_1.8.3  xfun_0.35       digest_0.6.30   rlang_1.0.6    \n[17] evaluate_0.18  \n\n\n\n\nWhere to ask for help?\n\nThe person sitting next to you during the workshop. Don’t hesitate to talk to your neighbor during the workshop, compare your answers, and ask for help. You might also be interested in organizing regular meetings following the workshop to keep learning from each other.\nYour friendly colleagues: if you know someone with more experience than you, they might be able and willing to help you.\nStack Overflow: if your question hasn’t been answered before and is well crafted, chances are you will get an answer in less than 5 min. Remember to follow their guidelines on how to ask a good question.\nThe R-help mailing list: it is read by a lot of people (including most of the R core team), a lot of people post to it, but the tone can be pretty dry, and it is not always very welcoming to new users. If your question is valid, you are likely to get an answer very fast but don’t expect that it will come with smiley faces. Also, here more than anywhere else, be sure to use correct vocabulary (otherwise you might get an answer pointing to the misuse of your words rather than answering your question). You will also have more success if your question is about a base function rather than a specific package.\nIf your question is about a specific package, see if there is a mailing list for it. Usually it’s included in the DESCRIPTION file of the package that can be accessed using packageDescription(\"name-of-package\"). You may also want to try to email the author of the package directly, or open an issue on the code repository (e.g., GitHub).\nThere are also some topic-specific mailing lists (GIS, phylogenetics, etc…), the complete list is here.\n\n\n\nMore resources\n\nThe Posting Guide for the R mailing lists.\nHow to ask for R help useful guidelines\nThis blog post by Jon Skeet has quite comprehensive advice on how to ask programming questions.\nThe reprex package is very helpful to create reproducible examples when asking for help. The [rOpenSci community call “How to ask questions so they get answered”], rOpenSci Blog and video recording includes a presentation of the reprex package and of its philosophy."
  },
  {
    "objectID": "intro-r-programming.html#creating-objects-in-r",
    "href": "intro-r-programming.html#creating-objects-in-r",
    "title": "2  Introduction to R",
    "section": "2.1 Creating objects in R",
    "text": "2.1 Creating objects in R\nYou can get output from R simply by typing math in the console:\n\n3 + 5\n\n[1] 8\n\n12 / 7\n\n[1] 1.714286\n\n\nHowever, to do useful and interesting things, we need to assign values to objects. To create an object, we need to give it a name followed by the assignment operator &lt;-, and the value we want to give it:\n\nweight_kg &lt;- 55\n\n&lt;- is the assignment operator. It assigns values on the right to objects on the left. So, after executing x &lt;- 3, the value of x is 3. The arrow can be read as 3 goes into x. For historical reasons, you can also use = for assignments, but not in every context. Because of the slight differences in syntax, it is good practice to always use &lt;- for assignments.\nIn RStudio, typing Alt + - (push Alt at the same time as the - key) will write &lt;- in a single keystroke in a PC, while typing Option + - (push Option at the same time as the - key) does the same in a Mac.\nObjects can be given any name such as x, current_temperature, or subject_id. You want your object names to be explicit and not too long. They cannot start with a number (2x is not valid, but x2 is). R is case sensitive (e.g., weight_kg is different from Weight_kg). There are some names that cannot be used because they are the names of fundamental functions in R (e.g., if, else, for, see here for a complete list). In general, even if it’s allowed, it’s best to not use other function names (e.g., c, T, mean, data, df, weights). If in doubt, check the help to see if the name is already in use. It’s also best to avoid dots (.) within an object name as in my.dataset. There are many functions in R with dots in their names for historical reasons, but because dots have a special meaning in R (for methods) and other programming languages, it’s best to avoid them. It is also recommended to use nouns for object names, and verbs for function names. It’s important to be consistent in the styling of your code (where you put spaces, how you name objects, etc.). Using a consistent coding style makes your code clearer to read for your future self and your collaborators. In R, three popular style guides are Google’s, Jean Fan’s and the tidyverse’s. The tidyverse’s is very comprehensive and may seem overwhelming at first. You can install the lintr package to automatically check for issues in the styling of your code.\n\n2.1.1 Objects vs. variables\nWhat are known as objects in R are known as variables in many other programming languages. Depending on the context, object and variable can have drastically different meanings. However, in this lesson, the two words are used synonymously. For more information see: https://cran.r-project.org/doc/manuals/r-release/R-lang.html#Objects\n\nWhen assigning a value to an object, R does not print anything. You can force R to print the value by using parentheses or by typing the object name:\n\nweight_kg &lt;- 55    # doesn't print anything\n(weight_kg &lt;- 55)  # but putting parenthesis around the call prints the value of `weight_kg`\n\n[1] 55\n\nweight_kg          # and so does typing the name of the object\n\n[1] 55\n\n\nNow that R has weight_kg in memory, we can do arithmetic with it. For instance, we may want to convert this weight into pounds (weight in pounds is 2.2 times the weight in kg):\n\n2.2 * weight_kg\n\n[1] 121\n\n\nWe can also change an object’s value by assigning it a new one:\n\nweight_kg &lt;- 57.5\n2.2 * weight_kg\n\n[1] 126.5\n\n\nThis means that assigning a value to one object does not change the values of other objects For example, let’s store the animal’s weight in pounds in a new object, weight_lb:\n\nweight_lb &lt;- 2.2 * weight_kg\n\nand then change weight_kg to 100.\n\nweight_kg &lt;- 100\n\nWhat do you think is the current content of the object weight_lb? 126.5 or 220?\n\n2.1.2 Comments\nThe comment character in R is #, anything to the right of a # in a script will be ignored by R. It is useful to leave notes and explanations in your scripts. RStudio makes it easy to comment or uncomment a paragraph: after selecting the lines you want to comment, press at the same time on your keyboard Ctrl + Shift + C. If you only want to comment out one line, you can put the cursor at any location of that line (i.e. no need to select the whole line), then press Ctrl + Shift + C.\n\n\n\n\n\n\nExercise 1\n\n\n\nLevel: \nWhat are the values after each statement in the following?\n\nmass &lt;- 47.5            # mass?\nage  &lt;- 122             # age?\nmass &lt;- mass * 2.0      # mass?\nage  &lt;- age - 20        # age?\nmass_index &lt;- mass/age  # mass_index?\n\n\n\n\n\n\n\nSolution for Exercise 1\n\n\n\n\n\n\nmass &lt;- 47.5            # mass is 47.5\nage  &lt;- 122             # age is 122\nmass &lt;- mass * 2.0      # mass is 95\nage  &lt;- age - 20        # age is 102\nmass_index &lt;- mass/age  # mass_index is 0.931\n\n\n\n\n\n\n\n\n2.1.3 Functions and their arguments\nFunctions are “canned scripts” that automate more complicated sets of commands including operations assignments, etc. Many functions are predefined, or can be made available by importing R packages (more on that later). A function usually takes one or more inputs called arguments. Functions often (but not always) return a value. A typical example would be the function sqrt(). The input (the argument) must be a number, and the return value (in fact, the output) is the square root of that number. Executing a function (‘running it’) is called calling the function. An example of a function call is:\n\nb &lt;- sqrt(a)\n\nHere, the value of a is given to the sqrt() function, the sqrt() function calculates the square root, and returns the value which is then assigned to the object b. This function is very simple, because it takes just one argument.\nThe return ‘value’ of a function need not be numerical (like that of sqrt()), and it also does not need to be a single item: it can be a set of things, or even a dataset. We’ll see that when we read data files into R.\nArguments can be anything, not only numbers or filenames, but also other objects. Exactly what each argument means differs per function, and must be looked up in the documentation (see below). Some functions take arguments which may either be specified by the user, or, if left out, take on a default value: these are called options. Options are typically used to alter the way the function operates, such as whether it ignores ‘bad values’, or what symbol to use in a plot. However, if you want something specific, you can specify a value of your choice which will be used instead of the default.\nLet’s try a function that can take multiple arguments: round().\n\nround(3.14159)\n\n[1] 3\n\n\nHere, we’ve called round() with just one argument, 3.14159, and it has returned the value 3. That’s because the default is to round to the nearest whole number. If we want more digits we can see how to do that by getting information about the round function. We can use args(round) to find what arguments it takes, or look at the help for this function using ?round.\n\nargs(round)\n\nfunction (x, digits = 0) \nNULL\n\n\n\n?round\n\nWe see that if we want a different number of digits, we can type digits = 2 or however many we want.\n\nround(3.14159, digits = 2)\n\n[1] 3.14\n\n\nIf you provide the arguments in the exact same order as they are defined you don’t have to name them:\n\nround(3.14159, 2)\n\n[1] 3.14\n\n\nAnd if you do name the arguments, you can switch their order:\n\nround(digits = 2, x = 3.14159)\n\n[1] 3.14\n\n\nIt’s good practice to put the non-optional arguments (like the number you’re rounding) first in your function call, and to then specify the names of all optional arguments. If you don’t, someone reading your code might have to look up the definition of a function with unfamiliar arguments to understand what you’re doing."
  },
  {
    "objectID": "intro-r-programming.html#vectors-and-data-types",
    "href": "intro-r-programming.html#vectors-and-data-types",
    "title": "2  Introduction to R",
    "section": "2.2 Vectors and data types",
    "text": "2.2 Vectors and data types\nA vector is the most common and basic data type in R, and is pretty much the workhorse of R. A vector is composed by a series of values, which can be either numbers or characters. We can assign a series of values to a vector using the c() function. For example we can create a vector of animal weights and assign it to a new object weight_g:\n\nweight_g &lt;- c(50, 60, 65, 82)\nweight_g\n\n[1] 50 60 65 82\n\n\nA vector can also contain characters:\n\nanimals &lt;- c(\"mouse\", \"rat\", \"dog\")\nanimals\n\n[1] \"mouse\" \"rat\"   \"dog\"  \n\n\nThe quotes around “mouse”, “rat”, etc. are essential here. Without the quotes R will assume objects have been created called mouse, rat and dog. As these objects don’t exist in R’s memory, there will be an error message.\nThere are many functions that allow you to inspect the content of a vector. length() tells you how many elements are in a particular vector:\n\nlength(weight_g)\n\n[1] 4\n\nlength(animals)\n\n[1] 3\n\n\nAn important feature of a vector, is that all of the elements are the same type of data. The function class() indicates the class (the type of element) of an object:\n\nclass(weight_g)\n\n[1] \"numeric\"\n\nclass(animals)\n\n[1] \"character\"\n\n\nThe function str() provides an overview of the structure of an object and its elements. It is a useful function when working with large and complex objects:\n\nstr(weight_g)\n\n num [1:4] 50 60 65 82\n\nstr(animals)\n\n chr [1:3] \"mouse\" \"rat\" \"dog\"\n\n\nYou can use the c() function to add other elements to your vector:\n\nweight_g &lt;- c(weight_g, 90) # add to the end of the vector\nweight_g &lt;- c(30, weight_g) # add to the beginning of the vector\nweight_g\n\n[1] 30 50 60 65 82 90\n\n\nIn the first line, we take the original vector weight_g, add the value 90 to the end of it, and save the result back into weight_g. Then we add the value 30 to the beginning, again saving the result back into weight_g.\nWe can do this over and over again to grow a vector, or assemble a dataset. As we program, this may be useful to add results that we are collecting or calculating.\nAn atomic vector is the simplest R data type and is a linear vector of a single type. Above, we saw 2 of the 6 main atomic vector types that R uses: \"character\" and \"numeric\" (or \"double\"). These are the basic building blocks that all R objects are built from. The other 4 atomic vector types are:\n\n\"logical\" for TRUE and FALSE (the boolean data type)\n\"integer\" for integer numbers (e.g., 2L, the L indicates to R that it’s an integer)\n\"complex\" to represent complex numbers with real and imaginary parts (e.g., 1 + 4i) and that’s all we’re going to say about them\n\"raw\" for bitstreams that we won’t discuss further\n\nYou can check the type of your vector using the typeof() function and inputting your vector as the argument.\nVectors are one of the many data structures that R uses. Other important ones are lists (list), matrices (matrix), data frames (data.frame), factors (factor) and arrays (array).\n\n\n\n\n\n\nExercise 2\n\n\n\nLevel: \nWhat are the values after each statement in the following?\n\nCreate a vector height_mm that contains the following heights of animals 100,150,99,87 in mm respectively.\nWhat is the total height of these animals in mm? (Hint: use function sum)\nAnother animal was measured and its height is 220mm. Add this to the beginning of the vector height_mm and save the total height of the new set of animals in the total_height variable. What is the new total_height?\n\n\n\n\n\n\n\nSolution for Exercise 2\n\n\n\n\n\nSolution for 2a:\n\nheight_mm &lt;- c(100, 150, 99, 87)\n\nSolution for 2b:\n\nsum(height_mm)\n\n[1] 436\n\n\nSolution for 2c:\n\nheight_mm &lt;- c(220, height_mm)\ntotal_height &lt;- sum(height_mm)"
  },
  {
    "objectID": "intro-r-programming.html#subsetting-vectors",
    "href": "intro-r-programming.html#subsetting-vectors",
    "title": "2  Introduction to R",
    "section": "2.3 Subsetting vectors",
    "text": "2.3 Subsetting vectors\nIf we want to extract one or several values from a vector, we must provide one or several indices in square brackets. For instance:\n\nanimals &lt;- c(\"mouse\", \"rat\", \"dog\", \"cat\")\nanimals[2]\n\n[1] \"rat\"\n\nanimals[c(3, 2)]\n\n[1] \"dog\" \"rat\"\n\n\nWe can also repeat the indices to create an object with more elements than the original one:\n\nmore_animals &lt;- animals[c(1, 2, 3, 2, 1, 4)]\nmore_animals\n\n[1] \"mouse\" \"rat\"   \"dog\"   \"rat\"   \"mouse\" \"cat\"  \n\n\nR indices start at 1. Programming languages like Fortran, MATLAB, Julia, and R start counting at 1, because that’s what human beings typically do. Languages in the C family (including C++, Java, Perl, and Python) count from 0 because that’s simpler for computers to do.\n\n2.3.1 Conditional subsetting\nAnother common way of subsetting is by using a logical vector. TRUE will select the element with the same index, while FALSE will not:\n\nweight_g &lt;- c(21, 34, 39, 54, 55)\nweight_g[c(TRUE, FALSE, TRUE, TRUE, FALSE)]\n\n[1] 21 39 54\n\n\nTypically, these logical vectors are not typed by hand, but are the output of other functions or logical tests. For instance, if you wanted to select only the values above 50:\n\nweight_g &gt; 50    # will return logicals with TRUE for the indices that meet the condition\n\n[1] FALSE FALSE FALSE  TRUE  TRUE\n\n## so we can use this to select only the values above 50\nweight_g[weight_g &gt; 50]\n\n[1] 54 55\n\n\nYou can combine multiple tests using & (both conditions are true, AND) or | (at least one of the conditions is true, OR):\n\nweight_g[weight_g &lt; 30 | weight_g &gt; 50]\n\n[1] 21 54 55\n\nweight_g[weight_g &gt;= 30 & weight_g == 21]\n\nnumeric(0)\n\n\nHere, &lt; stands for “less than”, &gt; for “greater than”, &gt;= for “greater than or equal to”, and == for “equal to”. The double equal sign == is a test for numerical equality between the left and right hand sides, and should not be confused with the single = sign, which performs variable assignment (similar to &lt;-).\nA common task is to search for certain strings in a vector. One could use the “or” operator | to test for equality to multiple values, but this can quickly become tedious. The function %in% allows you to test if any of the elements of a search vector are found:\n\nanimals &lt;- c(\"mouse\", \"rat\", \"dog\", \"cat\")\nanimals[animals == \"cat\" | animals == \"rat\"] # returns both rat and cat\n\n[1] \"rat\" \"cat\"\n\nanimals %in% c(\"rat\", \"cat\", \"dog\", \"duck\", \"goat\")\n\n[1] FALSE  TRUE  TRUE  TRUE\n\nanimals[animals %in% c(\"rat\", \"cat\", \"dog\", \"duck\", \"goat\")]\n\n[1] \"rat\" \"dog\" \"cat\""
  },
  {
    "objectID": "intro-r-programming.html#missing-data",
    "href": "intro-r-programming.html#missing-data",
    "title": "2  Introduction to R",
    "section": "2.4 Missing data",
    "text": "2.4 Missing data\nAs R was designed to analyze datasets, it includes the concept of missing data (which is uncommon in other programming languages). Missing data are represented in vectors as NA.\nWhen doing operations on numbers, most functions will return NA if the data you are working with include missing values. This feature makes it harder to overlook the cases where you are dealing with missing data. You can add the argument na.rm = TRUE to calculate the result while ignoring the missing values.\n\nheights &lt;- c(2, 4, 4, NA, 6)\nmean(heights)\n\n[1] NA\n\nmax(heights)\n\n[1] NA\n\nmean(heights, na.rm = TRUE)\n\n[1] 4\n\nmax(heights, na.rm = TRUE)\n\n[1] 6\n\n\nIf your data include missing values, you may want to become familiar with the functions is.na(), na.omit(), and complete.cases(). See below for examples.\n\n## Extract those elements which are not missing values.\nheights[!is.na(heights)]\n\n[1] 2 4 4 6\n\n## Returns the object with incomplete cases removed. The returned object is an atomic vector of type `\"numeric\"` (or `\"double\"`).\nna.omit(heights)\n\n[1] 2 4 4 6\nattr(,\"na.action\")\n[1] 4\nattr(,\"class\")\n[1] \"omit\"\n\n## Extract those elements which are complete cases. The returned object is an atomic vector of type `\"numeric\"` (or `\"double\"`).\nheights[complete.cases(heights)]\n\n[1] 2 4 4 6\n\n\nRecall that you can use the typeof() function to find the type of your atomic vector.\n\n\n\n\n\n\nExercise 3\n\n\n\nLevel: \n\nUsing this vector of heights in inches, create a new vector, heights_no_na, with the NAs removed.\n\nheights &lt;- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, \n             63, NA, 72, 65, 64, 70, 63, 65)\n\nUse the function median() to calculate the median of the heights vector.\nHow many people in the set are taller than 67 inches.\n\n\n\n\n\n\n\nSolution for Exercise 3\n\n\n\n\n\nSolution for 3a:\n\nheights &lt;- c(63, 69, 60, 65, NA, 68, 61, 70, 61, 59, 64, 69, 63, \n             63, NA, 72, 65, 64, 70, 63, 65)\n\nheights_no_na &lt;- heights[!is.na(heights)] \n# or\nheights_no_na &lt;- na.omit(heights)\n# or\nheights_no_na &lt;- heights[complete.cases(heights)]\n\nSolution for 3b:\n\nmedian(heights, na.rm = TRUE)\n\n[1] 64\n\n\nSolution for 3c:\n\nheights_above_67 &lt;- heights_no_na[heights_no_na &gt; 67]\nlength(heights_above_67)\n\n[1] 6"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "References",
    "section": "",
    "text": "Practical 1 was adapted from The Data Carpentry R Ecology Lesson1.\n\n\n1. Michonneau F, F. A., Teal T. Data carpentry:\nData analysis and visualization in r for ecologists. (2019) doi:10.5281/zenodo.3264888.\n\n\n2. H\nWickham, G. G., M Çetinkaya-Rundel. R for data science.\n(O’Reily Media, 2023)."
  },
  {
    "objectID": "starting-with-data.html#understanding-data",
    "href": "starting-with-data.html#understanding-data",
    "title": "3  Starting with data",
    "section": "3.1 Understanding data",
    "text": "3.1 Understanding data\nTo be able to do proper data analyses, it is crucial to understand your data before you can analyse it. So before we start doing any form of analyses we will first understand the dataset that we will be using throughout this course. Let us first download the file and have a look at the data.\nWe are going to use the R function download.file() to download the CSV file that contains the data. Run the code below in the R console:\n\ndownload.file(url=\"https://ndownloader.figshare.com/files/2292169\",\n              destfile = \"data/portal_data_joined.csv\")\n\nInside the download.file command, the first entry is a character string with the source URL. This source URL downloads a CSV file from figshare. The text after the comma (“data/portal_data_joined.csv”) is the destination of the file on your local machine.\nIf you go in the Files section in RStudio, click on the portal_data_joined.csv file in the data folder and then click View File you will be able to see the content of the file.\n\"record_id\",\"month\",\"day\",\"year\",\"plot_id\",\"species_id\",\"sex\",\"hindfoot_length\",\"weight\",\"genus\",\"species\",\"taxa\",\"plot_type\"\n1,7,16,1977,2,\"NL\",\"M\",\"32\",\"\",\"Neotoma\",\"albigula\",\"Rodent\",\"Control\"\n72,8,19,1977,2,\"NL\",\"M\",\"31\",\"\",\"Neotoma\",\"albigula\",\"Rodent\",\"Control\"  224,9,13,1977,2,\"NL\",\"\",\"\",\"\",\"Neotoma\",\"albigula\",\"Rodent\",\"Control\"\nFrom the first 4 lines of the portal_data_joined.csv file displayed above, we can notice that the file is in the comma separated value (CSV) format which is a very popular format where different values are separated by a comma. The first line of the file is the header of the file which provides a title for each column. In this dataset, we are studying the species repartition and weight of animals caught in plots in our study area. The dataset has the following columns, with each row holding information for a single animal:\n\n\n\nColumn\nDescription\n\n\n\n\nrecord_id\nUnique id for the observation\n\n\nmonth\nmonth of observation\n\n\nday\nday of observation\n\n\nyear\nyear of observation\n\n\nplot_id\nID of a particular plot\n\n\nspecies_id\n2-letter code\n\n\nsex\nsex of animal (“M”, “F”)\n\n\nhindfoot_length\nlength of the hindfoot in mm\n\n\nweight\nweight of the animal in grams\n\n\ngenus\ngenus of animal\n\n\nspecies\nspecies of animal\n\n\ntaxon\ne.g. Rodent, Reptile, Bird, Rabbit\n\n\nplot_type\ntype of plot"
  },
  {
    "objectID": "starting-with-data.html#reading-in-data-from-a-file",
    "href": "starting-with-data.html#reading-in-data-from-a-file",
    "title": "3  Starting with data",
    "section": "3.2 Reading in data from a file",
    "text": "3.2 Reading in data from a file\nNow that we have looked at the raw format of the file (CSV format), let us load the data into R and look at how data is loaded into R. We will use read.csv() to load into memory the content of the CSV file as an object of class data.frame.\nYou are now ready to load the data:\n\nsurveys &lt;- read.csv(\"data/portal_data_joined.csv\")\n\nThis statement doesn’t produce any output because, as you might recall, assignments don’t display anything. If we want to check that our data has been loaded, we can see the contents of the data frame by typing its name: surveys.\nWow… that was a lot of output. At least it means the data loaded properly. Let’s check the top (the first 6 lines) of this data frame using the function head():\n\nhead(surveys)\n\n  record_id month day year plot_id species_id sex hindfoot_length weight\n1         1     7  16 1977       2         NL   M              32     NA\n2        72     8  19 1977       2         NL   M              31     NA\n3       224     9  13 1977       2         NL                  NA     NA\n4       266    10  16 1977       2         NL                  NA     NA\n5       349    11  12 1977       2         NL                  NA     NA\n6       363    11  12 1977       2         NL                  NA     NA\n    genus  species   taxa plot_type\n1 Neotoma albigula Rodent   Control\n2 Neotoma albigula Rodent   Control\n3 Neotoma albigula Rodent   Control\n4 Neotoma albigula Rodent   Control\n5 Neotoma albigula Rodent   Control\n6 Neotoma albigula Rodent   Control\n\n\n\n## Try also\nView(surveys)\n\n\n\n\n\n\n\nNote\n\n\n\nread.csv assumes that fields are delineated by commas, however, in several countries, the comma is used as a decimal separator and the semicolon (;) is used as a field delineator. If you want to read in this type of files in R, you can use the read.csv2 function. It behaves exactly like read.csv but uses different parameters for the decimal and the field separators. If you are working with another format, they can be both specified by the user. Check out the help for read.csv() by typing ?read.csv to learn more. There is also the read.delim() for in tab separated data files. It is important to note that all of these functions are actually wrapper functions for the main read.table() function with different arguments. As such, the surveys data above could have also been loaded by using read.table() with the separation argument as ,. The code is as follows: surveys &lt;- read.table(file=\"data/portal_data_joined.csv\", sep=\",\", header=TRUE). The header argument has to be set to TRUE to be able to read the headers as by default read.table() has the header argument set to FALSE."
  },
  {
    "objectID": "starting-with-data.html#data-frames",
    "href": "starting-with-data.html#data-frames",
    "title": "3  Starting with data",
    "section": "3.3 Data frames",
    "text": "3.3 Data frames\nData frames are another data structure in R which is most widely used in the R programming world. It is very popular as most of the data is readily available in tabular form and it is the also the data structure used when plotting and performing most analyses in R.\nA data frame is the representation of data in the format of a table where the columns are vectors that all have the same length. Because columns are vectors, each column must contain a single type of data (e.g., characters, integers, logical). For example, here is a figure depicting a data frame comprising a numeric, a character, and a logical vector.\n\n\n\nFigure 3.1: Dataframe example1\n\n\nIn R we can see this by inspecting the structure of a data frame with the function str():\n\nstr(surveys)\n\n'data.frame':   34786 obs. of  13 variables:\n $ record_id      : int  1 72 224 266 349 363 435 506 588 661 ...\n $ month          : int  7 8 9 10 11 11 12 1 2 3 ...\n $ day            : int  16 19 13 16 12 12 10 8 18 11 ...\n $ year           : int  1977 1977 1977 1977 1977 1977 1977 1978 1978 1978 ...\n $ plot_id        : int  2 2 2 2 2 2 2 2 2 2 ...\n $ species_id     : chr  \"NL\" \"NL\" \"NL\" \"NL\" ...\n $ sex            : chr  \"M\" \"M\" \"\" \"\" ...\n $ hindfoot_length: int  32 31 NA NA NA NA NA NA NA NA ...\n $ weight         : int  NA NA NA NA NA NA NA NA 218 NA ...\n $ genus          : chr  \"Neotoma\" \"Neotoma\" \"Neotoma\" \"Neotoma\" ...\n $ species        : chr  \"albigula\" \"albigula\" \"albigula\" \"albigula\" ...\n $ taxa           : chr  \"Rodent\" \"Rodent\" \"Rodent\" \"Rodent\" ...\n $ plot_type      : chr  \"Control\" \"Control\" \"Control\" \"Control\" ...\n\n\n\n3.3.1 Inspecting data.frame Objects\nAs we mentioned before, it is important to understand your data before analysing it. Furthermore we want to make sure that the data has loaded in R properly. To do that, there are several functions we can use that help us to inspect our data.frame object.\nWe already saw how the functions head(), view() and str() can be useful to check the content and the structure of a data frame. Here is a non-exhaustive list of functions to get a sense of the content/structure of the data. Let’s try them out!\n\nSize:\n\ndim(surveys) - returns a vector with the number of rows in the first element, and the number of columns as the second element (the dimensions of the object)\nnrow(surveys) - returns the number of rows\nncol(surveys) - returns the number of columns\n\nContent:\n\nhead(surveys) - shows the first 6 rows\ntail(surveys) - shows the last 6 rows\n\nNames:\n\nnames(surveys) - returns the column names (synonym of colnames() for data.frame objects)\nrownames(surveys) - returns the row names\n\nSummary:\n\nstr(surveys) - structure of the object and information about the class, length and c content of each column\nsummary(surveys) - summary statistics for each column\n\n\n\n\n\n\n\n\nNote\n\n\n\nMost of these functions are “generic”, they can be used on other types of objects besides data.frame.\n\n\n\n\n\n\n\n\nExercise 4\n\n\n\nBased on the output of str(surveys), can you answer the following questions?\n\nWhat is the class of the object surveys?\nHow many rows and how many columns are in this object?\nWhich columns are of type character?\n\n\n\n\n\n\n\nSolution for Exercise 4\n\n\n\n\n\n\nstr(surveys)\n\n'data.frame':   34786 obs. of  13 variables:\n $ record_id      : int  1 72 224 266 349 363 435 506 588 661 ...\n $ month          : int  7 8 9 10 11 11 12 1 2 3 ...\n $ day            : int  16 19 13 16 12 12 10 8 18 11 ...\n $ year           : int  1977 1977 1977 1977 1977 1977 1977 1978 1978 1978 ...\n $ plot_id        : int  2 2 2 2 2 2 2 2 2 2 ...\n $ species_id     : chr  \"NL\" \"NL\" \"NL\" \"NL\" ...\n $ sex            : chr  \"M\" \"M\" \"\" \"\" ...\n $ hindfoot_length: int  32 31 NA NA NA NA NA NA NA NA ...\n $ weight         : int  NA NA NA NA NA NA NA NA 218 NA ...\n $ genus          : chr  \"Neotoma\" \"Neotoma\" \"Neotoma\" \"Neotoma\" ...\n $ species        : chr  \"albigula\" \"albigula\" \"albigula\" \"albigula\" ...\n $ taxa           : chr  \"Rodent\" \"Rodent\" \"Rodent\" \"Rodent\" ...\n $ plot_type      : chr  \"Control\" \"Control\" \"Control\" \"Control\" ...\n\n\n\nclass: data.frame\nrows: 34786, columns: 13\nnumber of rows of type character: species_id, sex, genus, species, taxa, plot_type\n\n\n\n\n\n\n\n\n3.3.2 Indexing and subsetting data frames\n\n3.3.2.1 Numeric indexing\nYou can think of a data frame as a table with rows and columns. Each element in the data frame can be indexed by the position of the row and the column in respect to the whole data frame. The index is specified as [R,C] where R is the position of the row (or row number) and C is the position of the column (or column number). Note that [] are used for indexing, while () are used to call a function. Indexing in a data frame starts from 1. To be able to extract specific data from the surveys data frame, we need to specify the indices or positions of the elements we want from it. In the image below we zoom into the first three columns and rows of the surveys data frame and show their indexes displayed on top of their values in skyblue.\n\n\n\nFigure 3.2: Numeric indexing in a dataframe\n\n\nThe illustration above illustrates how numeric indexing works. Below are some examples of how we can retrieve subset of values from the surveys data frame using numeric indexing.\n\n# get first element in the first column of the data frame\nsurveys[1, 1]   \n# get first element in the 6th column\nsurveys[1, 6]   \n# get first column of the data frame (as a vector)\nsurveys[, 1]    \n# get first three elements in the 7th column (as a vector)\nsurveys[1:3, 7] \n# get the 3rd row of the data frame (as a data.frame)\nsurveys[3, ]    \n# equivalent to head_surveys &lt;- head(surveys)\nhead_surveys &lt;- surveys[1:6, ] \n\n: is an operator in R that creates a sequence of numeric vectors of integers in increasing or decreasing order, test 1:10 and 10:1 for instance. It is equivalent to the function seq(from, to).\nYou can also exclude certain indices of a data frame using the “-” sign:\n\n# get the whole data frame, except the first column\nsurveys[, -1]   \n# equivalent to head(surveys)\nsurveys[-c(7:34786), ] \n\n\n\n3.3.2.2 Name indexing\nData frames can be subset by calling indices (as shown previously), but also by calling their row names and column names directly. This is known as name indexing. Below are some example of how we retrieve data from a data frame using column names.\n\n# get species_id column as a vector\nsurveys[, \"species_id\"]     \n# same as above\nsurveys$species_id          \n# get the record_id and species columns for the first three rows\n# Note: we are mixing numeric and name indexing here\nsurveys[1:3, c(\"record_id\", \"species\")] \n\nIn RStudio, you can use the autocompletion feature to get the full and correct names of the columns.\n\n\n3.3.2.3 Logical indexing\nAnother way to retrieve data from a data frame is by logical indexing, or in other words, by performing a logical operation on a data frame.\n\n# get all the records that have species as \"albigula\"\nsurveys[surveys$species == \"albigula\",]\n# save all the records that have species as \"albigula\" into a variable\nalbigula_data &lt;- surveys[surveys$species == \"albigula\",]\n# how many records have species as \"albigula\" in the surveys data frame?\nnrow(albigula_data)\n\nIn case you are wondering what a Neotoma albigula is: \n\n\n\n\n\n\nExercise 5\n\n\n\n\nCreate a data.frame (surveys_200) containing only the data in row 200 of the surveys dataset.\nRemember how nrow() gave you the number of rows in a data.frame?\n\n\nUse that number to pull out just that last row in the data frame.\nCompare that with what you see as the last row using tail() to make sure it’s meeting expectations.\nPull out that last row using nrow() instead of the row number.\nCreate a new data frame (surveys_last) from that last row.\n\n\nUse nrow() to extract the row that is in the middle of the data frame. Store the content of this row in an object named surveys_middle.\nCombine nrow() with the - notation above to reproduce the behavior of head(surveys), keeping just the first through 6th rows of the surveys dataset.\n\n\n\n\n\n\n\nSolution for Exercise 5\n\n\n\n\n\n\n# a.\nsurveys_200 &lt;- surveys[200, ]\n\n# b.\n# Saving `n_rows` to improve readability and reduce duplication\nn_rows &lt;- nrow(surveys)\nsurveys_last &lt;- surveys[n_rows, ]\n\n# c.\nsurveys_middle &lt;- surveys[n_rows / 2, ]\n\n# d.\nsurveys_head &lt;- surveys[-(7:n_rows), ]"
  },
  {
    "objectID": "starting-with-data.html#factors",
    "href": "starting-with-data.html#factors",
    "title": "3  Starting with data",
    "section": "3.4 Factors",
    "text": "3.4 Factors\nWhen we did str(surveys) we saw that several of the columns consist of integers. The columns genus, species, sex, plot_type, … however, are of the class character. Arguably, these columns contain categorical data, that is, they can only take on a limited number of values.\nR has a special class for working with categorical data, called factor. Factors are very useful and actually contribute to making R particularly well suited to working with data. So we are going to spend a little time introducing them.\nOnce created, factors can only contain a pre-defined set of values, known as levels. Factors are stored as integers associated with labels and they can be ordered or unordered. While factors look (and often behave) like character vectors, they are actually treated as integer vectors by R. So you need to be very careful when treating them as strings.\nWe can convert these columns that contain categorical data to type factor by using the factor() function:\n\nsurveys$sex &lt;- factor(surveys$sex)\n\nWe can see that the conversion has worked by using the summary() function again. This produces a table with the counts for each factor level:\n\nsummary(surveys$sex)\n\n          F     M \n 1748 15690 17348 \n\n\nBy default, R always sorts levels in alphabetical order. For instance, if you have a factor with 2 levels:\n\nsex &lt;- factor(c(\"male\", \"female\", \"female\", \"male\"))\n\nR will assign 1 to the level \"female\" and 2 to the level \"male\" (because f comes before m, even though the first element in this vector is \"male\"). You can see this by using the function levels() and you can find the number of levels using nlevels():\n\nlevels(sex)\n\n[1] \"female\" \"male\"  \n\nnlevels(sex)\n\n[1] 2\n\n\nSometimes, the order of the factors does not matter, other times you might want to specify the order because it is meaningful (e.g., “low”, “medium”, “high”), it improves your visualization, or it is required by a particular type of analysis. Here, one way to reorder our levels in the sex vector would be:\n\nsex # current order\n\n[1] male   female female male  \nLevels: female male\n\nsex &lt;- factor(sex, levels = c(\"male\", \"female\"))\nsex # after re-ordering\n\n[1] male   female female male  \nLevels: male female\n\n\nIn R’s memory, these factors are represented by integers (1, 2, 3), but are more informative than integers because factors are self describing: \"female\", \"male\" is more descriptive than 1, 2. Which one is “male”? You wouldn’t be able to tell just from the integer data. Factors, on the other hand, have this information built in. It is particularly helpful when there are many levels (like the species names in our example dataset).\n\n\n\n\n\n\nExercise 6\n\n\n\n\nChange the columns taxa and genus in the surveys data frame into a factor.\nUsing the functions you learned before, can you find out…\n\n\nHow many rabbits were observed?\nHow many different genera are in the genus column?\n\n\n\n\n\n\n\nSolution for Exercise 6\n\n\n\n\n\n\n# a\nsurveys$taxa &lt;- factor(surveys$taxa)\nsurveys$genus &lt;- factor(surveys$genus)\n\n#b\nsummary(surveys)\n\n   record_id         month             day            year         plot_id     \n Min.   :    1   Min.   : 1.000   Min.   : 1.0   Min.   :1977   Min.   : 1.00  \n 1st Qu.: 8964   1st Qu.: 4.000   1st Qu.: 9.0   1st Qu.:1984   1st Qu.: 5.00  \n Median :17762   Median : 6.000   Median :16.0   Median :1990   Median :11.00  \n Mean   :17804   Mean   : 6.474   Mean   :16.1   Mean   :1990   Mean   :11.34  \n 3rd Qu.:26655   3rd Qu.:10.000   3rd Qu.:23.0   3rd Qu.:1997   3rd Qu.:17.00  \n Max.   :35548   Max.   :12.000   Max.   :31.0   Max.   :2002   Max.   :24.00  \n                                                                               \n  species_id        sex       hindfoot_length     weight      \n Length:34786        : 1748   Min.   : 2.00   Min.   :  4.00  \n Class :character   F:15690   1st Qu.:21.00   1st Qu.: 20.00  \n Mode  :character   M:17348   Median :32.00   Median : 37.00  \n                              Mean   :29.29   Mean   : 42.67  \n                              3rd Qu.:36.00   3rd Qu.: 48.00  \n                              Max.   :70.00   Max.   :280.00  \n                              NA's   :3348    NA's   :2503    \n             genus         species               taxa        plot_type        \n Dipodomys      :16167   Length:34786       Bird   :  450   Length:34786      \n Chaetodipus    : 6029   Class :character   Rabbit :   75   Class :character  \n Onychomys      : 3267   Mode  :character   Reptile:   14   Mode  :character  \n Reithrodontomys: 2694                      Rodent :34247                     \n Peromyscus     : 2234                                                        \n Perognathus    : 1629                                                        \n (Other)        : 2766                                                        \n\n#b.i\nnlevels(surveys$genus)\n\n[1] 26\n\n# There are 26 unique genera in the `genus` column.\n\n#b.ii:  There are 75 rabbits in the `taxa` column.\n\n\n\n\n\n\n\n3.4.1 Converting factors\nIf you need to convert a factor to a character vector, you use as.character(x).\n\nas.character(sex)\n\n[1] \"male\"   \"female\" \"female\" \"male\"  \n\n\nIn some cases, you may have to convert factors where the levels appear as numbers (such as concentration levels or years) to a numeric vector. For instance, in one part of your analysis the years might need to be encoded as factors (e.g., comparing average weights across years) but in another part of your analysis they may need to be stored as numeric values (e.g., doing math operations on the years). This conversion from factor to numeric is a little trickier. The as.numeric() function returns the index values of the factor, not its levels, so it will result in an entirely new (and unwanted in this case) set of numbers. One method to avoid this is to convert factors to characters, and then to numbers.\nAnother method is to use the levels() function. Compare:\n\nyear_fct &lt;- factor(c(1990, 1983, 1977, 1998, 1990))\nas.numeric(year_fct)               # Wrong! And there is no warning...\n\n[1] 3 2 1 4 3\n\nas.numeric(as.character(year_fct)) # Works...\n\n[1] 1990 1983 1977 1998 1990\n\nas.numeric(levels(year_fct))[year_fct]    # The recommended way.\n\n[1] 1990 1983 1977 1998 1990\n\n\nNotice that in the levels() approach, three important steps occur:\n\nWe obtain all the factor levels using levels(year_fct)\nWe convert these levels to numeric values using as.numeric(levels(year_fct))\nWe then access these numeric values using the underlying integers of the vector year_fct inside the square brackets\n\n\n\n\n\n1. Michonneau F, F. A., Teal T. Data carpentry: Data analysis and visualization in r for ecologists. (2019) doi:10.5281/zenodo.3264888."
  },
  {
    "objectID": "starting-with-data.html#optional-sections",
    "href": "starting-with-data.html#optional-sections",
    "title": "3  Starting with data",
    "section": "3.5 Optional sections",
    "text": "3.5 Optional sections\n\n3.5.1 Renaming factors\nWhen your data is stored as a factor, you can use the plot() function to get a quick glance at the number of observations represented by each factor level. Let’s look at the number of males and females captured over the course of the experiment:\n\n## bar plot of the number of females and males captured during the experiment:\nplot(surveys$sex)\n\n\n\n\nHowever, as we saw when we used summary(surveys$sex), there are about 1700 individuals for which the sex information hasn’t been recorded. To show them in the plot, we can turn the missing values into a factor level. We will also have to give the new factor level a label. We are going to work with a copy of the sex column, so we’re not modifying the working copy of the data frame:\n\nsex &lt;- as.factor(surveys$sex)\nhead(sex)\n\n[1] M M        \nLevels:  F M\n\nlevels(sex)\n\n[1] \"\"  \"F\" \"M\"\n\nlevels(sex)[1] &lt;- \"undetermined\"\nlevels(sex)\n\n[1] \"undetermined\" \"F\"            \"M\"           \n\nhead(sex)\n\n[1] M            M            undetermined undetermined undetermined\n[6] undetermined\nLevels: undetermined F M\n\n\nNow we can plot the data again, using plot(sex).\n\n\n\n\n\n\n3.5.2 Challenge\n\nRename “F” and “M” to “female” and “male” respectively.\nNow that we have renamed the factor level to “undetermined”, can you recreate the barplot such that “undetermined” is last (after “male”)?\n\n\nlevels(sex)[2:3] &lt;- c(\"female\", \"male\")\nsex &lt;- factor(sex, levels = c(\"female\", \"male\", \"undetermined\"))\nplot(sex)\n\n\n\n\n\n\n\n3.5.3 Using stringsAsFactors=TRUE\nDepending on what you want to do with the data, when you have a column with categorical data you may want to keep these columns as character or else you may want to change them to factor. To do so, read.csv() and read.table() have an argument called stringsAsFactors which can be set to TRUE.\n\n## Compare the difference between our data read as `factor` vs `character`.\nsurveys &lt;- read.csv(\"data/portal_data_joined.csv\", stringsAsFactors = TRUE)\nstr(surveys)\nsurveys &lt;- read.csv(\"data/portal_data_joined.csv\", stringsAsFactors = FALSE)\nstr(surveys)\n## Convert the column \"plot_type\" into a factor\nsurveys$plot_type &lt;- factor(surveys$plot_type)\n\n\n3.5.4 Challenge\n\nWe have seen how data frames are created when using read.csv(), but they can also be created by hand with the data.frame() function. There are a few mistakes in this hand-crafted data.frame. Can you spot and fix them? Don’t hesitate to experiment!\n::: {.cell}\nanimal_data &lt;- data.frame(\n          animal = c(dog, cat, sea cucumber, sea urchin),\n          feel = c(\"furry\", \"squishy\", \"spiny\"),\n          weight = c(45, 8 1.1, 0.8)\n          )\n::: ::: {.cell}\n\n:::\n\nCan you predict the class for each of the columns in the following example? Check your guesses using str(country_climate):\n\nAre they what you expected? Why? Why not?\nWhat would have been different if we had added stringsAsFactors = FALSE when creating the data frame?\nWhat would you need to change to ensure that each column had the accurate data type?\n\n::: {.cell}\ncountry_climate &lt;- data.frame(\n       country = c(\"Canada\", \"Panama\", \"South Africa\", \"Australia\"),\n       climate = c(\"cold\", \"hot\", \"temperate\", \"hot/temperate\"),\n       temperature = c(10, 30, 18, \"15\"),\n       northern_hemisphere = c(TRUE, TRUE, FALSE, \"FALSE\"),\n       has_kangaroo = c(FALSE, FALSE, FALSE, 1)\n       )\n:::\n\n\nThe automatic conversion of data type is sometimes a blessing, sometimes an annoyance. Be aware that it exists, learn the rules, and double check that data you import in R are of the correct type within your data frame. If not, use it to your advantage to detect mistakes that might have been introduced during data entry (for instance, a letter in a column that should only contain numbers).\n\n\n\n\n1. Michonneau F, F. A., Teal T. Data carpentry: Data analysis and visualization in r for ecologists. (2019) doi:10.5281/zenodo.3264888."
  },
  {
    "objectID": "starting-with-data.html",
    "href": "starting-with-data.html",
    "title": "3  Starting with data",
    "section": "",
    "text": "4 Saving n_rows to improve readability and reduce duplication\nn_rows &lt;- nrow(surveys) surveys_last &lt;- surveys[n_rows, ]"
  },
  {
    "objectID": "starting-with-data.html#exercise-5",
    "href": "starting-with-data.html#exercise-5",
    "title": "3  Starting with data",
    "section": "3.4 Exercise 5",
    "text": "3.4 Exercise 5\n\nCreate a data.frame (surveys_200) containing only the data in row 200 of the surveys dataset.\nRemember how nrow() gave you the number of rows in a data.frame?\nUse that number to pull out just that last row in the data frame.\n\n\nCompare that with what you see as the last row using tail() to make sure it’s meeting expectations.\nPull out that last row using nrow() instead of the row number.\nCreate a new data frame (surveys_last) from that last row.\nUse nrow() to extract the row that is in the middle of the data frame. Store the content of this row in an object named surveys_middle.\nCombine nrow() with the - notation above to reproduce the behavior of head(surveys), keeping just the first through 6th rows of the surveys dataset.\n\n\n\n\n\n\n\nSolution for Exercise 5\n\n\n\n\n\n``{r, purl=FALSE} ## a. surveys_200 &lt;- surveys[200, ]\n\n3.5 b.\n\n\n\n\n\n4.1 c.\nsurveys_middle &lt;- surveys[n_rows / 2, ]\n\n\n4.2 d.\nsurveys_head &lt;- surveys[-(7:n_rows), ]\n\n\n## Factors\n\n::: {.cell}\n\n:::\n\nWhen we did `str(surveys)` we saw that several of the columns consist of\nintegers. The columns `genus`, `species`, `sex`, `plot_type`, ... however, are\nof the class `character`. Arguably, these columns contain categorical data, that is, they can only take on a limited number of values.\n\nR has a special class for working with categorical data, called `factor`. Factors are very useful and actually contribute to making R particularly well suited to working with data. So we are going to spend a little time introducing them.\n\nOnce created, factors can only contain a pre-defined set of values, known as\n*levels*.  Factors are stored as integers associated with labels and they can be ordered or unordered. While factors look (and often behave) like character vectors, they are actually treated as integer vectors by R. So you need to be very careful when treating them as strings.\n\nWe can convert these columns that contain categorical data to type factor by using the `factor()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys$sex &lt;- factor(surveys$sex)\n\n\n\n\n\nWe can see that the conversion has worked by using the summary() function again. This produces a table with the counts for each factor level:\n\nsummary(surveys$sex)\n\n          F     M \n 1748 15690 17348 \n\n\nBy default, R always sorts levels in alphabetical order. For instance, if you have a factor with 2 levels:\n\nsex &lt;- factor(c(\"male\", \"female\", \"female\", \"male\"))\n\nR will assign 1 to the level \"female\" and 2 to the level \"male\" (because f comes before m, even though the first element in this vector is \"male\"). You can see this by using the function levels() and you can find the number of levels using nlevels():\n\nlevels(sex)\n\n[1] \"female\" \"male\"  \n\nnlevels(sex)\n\n[1] 2\n\n\nSometimes, the order of the factors does not matter, other times you might want to specify the order because it is meaningful (e.g., “low”, “medium”, “high”), it improves your visualization, or it is required by a particular type of analysis. Here, one way to reorder our levels in the sex vector would be:\n\nsex # current order\n\n[1] male   female female male  \nLevels: female male\n\nsex &lt;- factor(sex, levels = c(\"male\", \"female\"))\nsex # after re-ordering\n\n[1] male   female female male  \nLevels: male female\n\n\nIn R’s memory, these factors are represented by integers (1, 2, 3), but are more informative than integers because factors are self describing: \"female\", \"male\" is more descriptive than 1, 2. Which one is “male”? You wouldn’t be able to tell just from the integer data. Factors, on the other hand, have this information built in. It is particularly helpful when there are many levels (like the species names in our example dataset).\n\n4.2.1 Challenge\n\nChange the columns taxa and genus in the surveys data frame into a factor.\nUsing the functions you learned before, can you find out…\n\nHow many rabbits were observed?\nHow many different genera are in the genus column?\n\n\n\nsurveys$genus &lt;- factor(surveys$genus)\nsummary(surveys)\n\n   record_id         month             day            year         plot_id     \n Min.   :    1   Min.   : 1.000   Min.   : 1.0   Min.   :1977   Min.   : 1.00  \n 1st Qu.: 8964   1st Qu.: 4.000   1st Qu.: 9.0   1st Qu.:1984   1st Qu.: 5.00  \n Median :17762   Median : 6.000   Median :16.0   Median :1990   Median :11.00  \n Mean   :17804   Mean   : 6.474   Mean   :16.1   Mean   :1990   Mean   :11.34  \n 3rd Qu.:26655   3rd Qu.:10.000   3rd Qu.:23.0   3rd Qu.:1997   3rd Qu.:17.00  \n Max.   :35548   Max.   :12.000   Max.   :31.0   Max.   :2002   Max.   :24.00  \n                                                                               \n  species_id        sex       hindfoot_length     weight      \n Length:34786        : 1748   Min.   : 2.00   Min.   :  4.00  \n Class :character   F:15690   1st Qu.:21.00   1st Qu.: 20.00  \n Mode  :character   M:17348   Median :32.00   Median : 37.00  \n                              Mean   :29.29   Mean   : 42.67  \n                              3rd Qu.:36.00   3rd Qu.: 48.00  \n                              Max.   :70.00   Max.   :280.00  \n                              NA's   :3348    NA's   :2503    \n             genus         species              taxa          \n Dipodomys      :16167   Length:34786       Length:34786      \n Chaetodipus    : 6029   Class :character   Class :character  \n Onychomys      : 3267   Mode  :character   Mode  :character  \n Reithrodontomys: 2694                                        \n Peromyscus     : 2234                                        \n Perognathus    : 1629                                        \n (Other)        : 2766                                        \n  plot_type        \n Length:34786      \n Class :character  \n Mode  :character  \n                   \n                   \n                   \n                   \n\nnlevels(surveys$genus)\n\n[1] 26\n\n## * how many genera: There are 26 unique genera in the `genus` column.\n## * how many rabbits: There are 75 rabbits in the `taxa` column.\n\n\n\n4.2.2 Converting factors\nIf you need to convert a factor to a character vector, you use as.character(x).\n\nas.character(sex)\n\n[1] \"male\"   \"female\" \"female\" \"male\"  \n\n\nIn some cases, you may have to convert factors where the levels appear as numbers (such as concentration levels or years) to a numeric vector. For instance, in one part of your analysis the years might need to be encoded as factors (e.g., comparing average weights across years) but in another part of your analysis they may need to be stored as numeric values (e.g., doing math operations on the years). This conversion from factor to numeric is a little trickier. The as.numeric() function returns the index values of the factor, not its levels, so it will result in an entirely new (and unwanted in this case) set of numbers. One method to avoid this is to convert factors to characters, and then to numbers.\nAnother method is to use the levels() function. Compare:\n\nyear_fct &lt;- factor(c(1990, 1983, 1977, 1998, 1990))\nas.numeric(year_fct)               # Wrong! And there is no warning...\n\n[1] 3 2 1 4 3\n\nas.numeric(as.character(year_fct)) # Works...\n\n[1] 1990 1983 1977 1998 1990\n\nas.numeric(levels(year_fct))[year_fct]    # The recommended way.\n\n[1] 1990 1983 1977 1998 1990\n\n\nNotice that in the levels() approach, three important steps occur:\n\nWe obtain all the factor levels using levels(year_fct)\nWe convert these levels to numeric values using as.numeric(levels(year_fct))\nWe then access these numeric values using the underlying integers of the vector year_fct inside the square brackets"
  },
  {
    "objectID": "starting-with-data.html#b.",
    "href": "starting-with-data.html#b.",
    "title": "3  Starting with data",
    "section": "3.5 b.",
    "text": "3.5 b."
  },
  {
    "objectID": "starting-with-data.html#c.",
    "href": "starting-with-data.html#c.",
    "title": "3  Starting with data",
    "section": "4.1 c.",
    "text": "4.1 c.\nsurveys_middle &lt;- surveys[n_rows / 2, ]"
  },
  {
    "objectID": "starting-with-data.html#d.",
    "href": "starting-with-data.html#d.",
    "title": "3  Starting with data",
    "section": "4.2 d.",
    "text": "4.2 d.\nsurveys_head &lt;- surveys[-(7:n_rows), ]\n\n\n## Factors\n\n::: {.cell}\n\n:::\n\nWhen we did `str(surveys)` we saw that several of the columns consist of\nintegers. The columns `genus`, `species`, `sex`, `plot_type`, ... however, are\nof the class `character`. Arguably, these columns contain categorical data, that is, they can only take on a limited number of values.\n\nR has a special class for working with categorical data, called `factor`. Factors are very useful and actually contribute to making R particularly well suited to working with data. So we are going to spend a little time introducing them.\n\nOnce created, factors can only contain a pre-defined set of values, known as\n*levels*.  Factors are stored as integers associated with labels and they can be ordered or unordered. While factors look (and often behave) like character vectors, they are actually treated as integer vectors by R. So you need to be very careful when treating them as strings.\n\nWe can convert these columns that contain categorical data to type factor by using the `factor()` function:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsurveys$sex &lt;- factor(surveys$sex)"
  },
  {
    "objectID": "practical2.html",
    "href": "practical2.html",
    "title": "Practical 2",
    "section": "",
    "text": "Data Visualisation and Manipulation in R"
  },
  {
    "objectID": "practical2.html#aim",
    "href": "practical2.html#aim",
    "title": "Practical 2",
    "section": "Aim",
    "text": "Aim\nThe aim of this practical is to introduce you to tidyverse and learn how we can visualise data using ggplot2 and data manipulation using dplyr."
  },
  {
    "objectID": "practical2.html#objectives",
    "href": "practical2.html#objectives",
    "title": "Practical 2",
    "section": "Objectives",
    "text": "Objectives\nDuring this practical you will learn:\n\nabout the data science workflow\nhow to load packages in R\nuse tidyverse to perform data operations\nvisualise data with ggplot\ntransform data with dplyr"
  },
  {
    "objectID": "practical2.html#instructions",
    "href": "practical2.html#instructions",
    "title": "Practical 2",
    "section": "Instructions",
    "text": "Instructions\nThe best way to do this practical is to read the Practical Notes which will introduce you to the core concepts of R programming. These notes are designed with all the details you would need to be able to perform the exercises in this practical. In general, you would not need to refer to additional texts and resources as these notes have been explained in detail. Apart from the exercises listed below, there are also examples throughout the notes which provide insight on the concepts introduced, and therefore, it is recommended that you also run these examples as you progress through the practical notes.\nIf you are an experienced R programmer, you might find that you already know about the content in these notes. You may want to skip sections of notes that you already know and attempt the exercises that are at the higher levels.\n\nExercises levels\nExercises in this practical are labelled with the level of difficulty of the respective exercise:\n\n\n\n\n\n\n\nLevel\nDescription\n\n\n\n\n\nLevel 1: Exercises in Level 1 are simple exercises designed to get you familiar with the R syntax. If you already know how to program in R, you may skip these exercises.\n\n\n\nLevel 2: Exercises in Level 2 combine different R programming concepts to solve simple problems.\n\n\n\nLevel 3: Exercises in Level 3 solve more complex problems.\n\n\n\n\n\nExercises\nThis practical is composed of the following exercises:\n\n\n\nExercise\nDescription\nLevel\n\n\n\n\nExercise 7\nDrawing plots: In this exercise we will practice drawing plots.\n\n\n\nExercise 8\nPipes: In this exercise we will practice using pipes.\n\n\n\nExercise 9\nScatter plot highlight: This exercises uses pipes to highlight a subset in the data on a scatter plot.\n\n\n\nExercise 10\nBox plot: Here we will learn how to deal with categorised data and plot them in box plots.\n\n\n\n\n\n\n\n\n\n\nManaged to solve all the exercises? Second badge earned!\n\n\n\n In the programming world, many organisations award badges to learners on the acquisition of a new skill or completion of a milestone. If you attempted and solved all the exercises of this practical, you definitely deserve your second R badge of this course."
  },
  {
    "objectID": "tidyverse1.html",
    "href": "tidyverse1.html",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "",
    "text": "5 Transforming data - dplyr\nIn most of the cases you will need to change the format of your dataset because it will not be in the right format that you will need to plot or analyse the data. tidyverse has a package called dplyr which contains functions that help you to select columns/rows, sort, combine and perform other data types of data transformations. In the next sections we will look at different ways to transform our dataset. Now that we already know the basics of visualing data with ggplot we will also learn how to visualise other plots with the transformed dataset as we go along."
  },
  {
    "objectID": "tidyverse1.html#tidyverse",
    "href": "tidyverse1.html#tidyverse",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "5.1 Tidyverse",
    "text": "5.1 Tidyverse\nThe package that we will be using in this course is called tidyverse. It is an “umbrella-package” that contains several packages useful for data manipulation and visualisation which work well together such as readr, tidyr, dplyr, ggplot2, tibble, etc…\n\nTidyverse is a recent package (launched in 2016) when compared to R base (stable version in 2000), thus you will still come across R resources that do not use tidyverse. However, since its’ release, tidyverse has been increasing in popularity throughout the R programming community and it is now very popular in Data Science as it was designed with the aim to help Data Scientists perform their tasks more efficiently.\nSome of the main advantages of tidyverse over R base are:\n\nEasier to read \n\nBracket subsetting is handy, but it can be cumbersome and difficult to read, especially for complicated operations.\n\n\ne.g. Get only the rows that have species as albigula surveyed in the year 1977.\n\n\n# R Base\nsurveys[surveys$species==\"albigula\" &\n        surveys$year==1977, ]\n\n# tidyverse\nfilter(surveys, species==\"albigula\" & year==1977)\n\n\nFaster\n\nUsing tidyverse is up to 10x faster1 when compared to the corresponding base R base functions.\n\nStrings are not converted to factor\n\nWe have seen in our previous lesson that when building or importing a data frame, the columns that contain characters (i.e., text) are coerced (=converted) into the factor data type. We had to set stringsAsFactors to FALSE to avoid this hidden argument to convert our data type. With tidyverse, this does not happen.\n\n\n\n5.1.1 Installing and loading packages\nBefore using a package for the first time you will need to install it on your machine, and then you should import it in every subsequent R session when you need it. To install a package in R on your machine you need to use the install.packages function. To install the tidyverse package type the following straight into the console:\n\n#install the tidyverse package\ninstall.packages(\"tidyverse\")\n\nIt is better to install packages straight from the console then from your script as there’s no need to re-install packages every time you run the script.\nThen, to load the package type:\n\n## load the tidyverse package\nlibrary(tidyverse)"
  },
  {
    "objectID": "tidyverse1.html#tibble",
    "href": "tidyverse1.html#tibble",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.4 Tibble",
    "text": "4.4 Tibble\nAfter importing data into R we need to check if the data has been loaded into R correctly.\n\n## display the first 6 rows of the dataset\nhead(surveys)\n\n# A tibble: 6 × 13\n  record_id month   day  year plot_id speci…¹ sex   hindf…² weight genus species\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  \n1         1     7    16  1977       2 NL      M          32     NA Neot… albigu…\n2        72     8    19  1977       2 NL      M          31     NA Neot… albigu…\n3       224     9    13  1977       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n4       266    10    16  1977       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n5       349    11    12  1977       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n6       363    11    12  1977       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n# … with 2 more variables: taxa &lt;chr&gt;, plot_type &lt;chr&gt;, and abbreviated\n#   variable names ¹​species_id, ²​hindfoot_length\n\n\nNotice that the first line of the output shows the data structure used to store the data imported into: tibble. tibble is the main data structure used in tidyverse. You can look at tibble as the data.frame version of tidyverse. The first immediate difference from a data.frame is that a tibble displays the data type of each column under its name and it only prints as many columns as fit on one screen. Furthermore as mentioned before, the columns of class character are never converted into factor. Another difference is that printing a tibble will not print the whole dataset, but just the first 10 rows and only the columns that fit the screen (same as head but with 10 rows instead of 6). If you would like to print more than the first 10 rows use the print function.\n\n#print the first 15 rows\nprint(surveys, n=15)\n\n# A tibble: 34,786 × 13\n   record…¹ month   day  year plot_id speci…² sex   hindf…³ weight genus species\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  \n 1        1     7    16  1977       2 NL      M          32     NA Neot… albigu…\n 2       72     8    19  1977       2 NL      M          31     NA Neot… albigu…\n 3      224     9    13  1977       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n 4      266    10    16  1977       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n 5      349    11    12  1977       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n 6      363    11    12  1977       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n 7      435    12    10  1977       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n 8      506     1     8  1978       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n 9      588     2    18  1978       2 NL      M          NA    218 Neot… albigu…\n10      661     3    11  1978       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n11      748     4     8  1978       2 NL      &lt;NA&gt;       NA     NA Neot… albigu…\n12      845     5     6  1978       2 NL      M          32    204 Neot… albigu…\n13      990     6     9  1978       2 NL      M          NA    200 Neot… albigu…\n14     1164     8     5  1978       2 NL      M          34    199 Neot… albigu…\n15     1261     9     4  1978       2 NL      M          32    197 Neot… albigu…\n# … with 34,771 more rows, 2 more variables: taxa &lt;chr&gt;, plot_type &lt;chr&gt;, and\n#   abbreviated variable names ¹​record_id, ²​species_id, ³​hindfoot_length\n\n\nSince printing tibble already gives you information about the data structure, the data types of each column and the size of the dataset, the str function is not as much useful as it was when using data.frame.\n\n## inspect the data\nstr(surveys)\n\nspc_tbl_ [34,786 × 13] (S3: spec_tbl_df/tbl_df/tbl/data.frame)\n $ record_id      : num [1:34786] 1 72 224 266 349 363 435 506 588 661 ...\n $ month          : num [1:34786] 7 8 9 10 11 11 12 1 2 3 ...\n $ day            : num [1:34786] 16 19 13 16 12 12 10 8 18 11 ...\n $ year           : num [1:34786] 1977 1977 1977 1977 1977 ...\n $ plot_id        : num [1:34786] 2 2 2 2 2 2 2 2 2 2 ...\n $ species_id     : chr [1:34786] \"NL\" \"NL\" \"NL\" \"NL\" ...\n $ sex            : chr [1:34786] \"M\" \"M\" NA NA ...\n $ hindfoot_length: num [1:34786] 32 31 NA NA NA NA NA NA NA NA ...\n $ weight         : num [1:34786] NA NA NA NA NA NA NA NA 218 NA ...\n $ genus          : chr [1:34786] \"Neotoma\" \"Neotoma\" \"Neotoma\" \"Neotoma\" ...\n $ species        : chr [1:34786] \"albigula\" \"albigula\" \"albigula\" \"albigula\" ...\n $ taxa           : chr [1:34786] \"Rodent\" \"Rodent\" \"Rodent\" \"Rodent\" ...\n $ plot_type      : chr [1:34786] \"Control\" \"Control\" \"Control\" \"Control\" ...\n - attr(*, \"spec\")=\n  .. cols(\n  ..   record_id = col_double(),\n  ..   month = col_double(),\n  ..   day = col_double(),\n  ..   year = col_double(),\n  ..   plot_id = col_double(),\n  ..   species_id = col_character(),\n  ..   sex = col_character(),\n  ..   hindfoot_length = col_double(),\n  ..   weight = col_double(),\n  ..   genus = col_character(),\n  ..   species = col_character(),\n  ..   taxa = col_character(),\n  ..   plot_type = col_character()\n  .. )\n - attr(*, \"problems\")=&lt;externalptr&gt; \n\n\nNotice that rather than specifying tibble as the data structure of surveys, the first line of str’s output now specifies ‘spec_tbl_df’, ‘tbl_df’, ‘tbl’ and 'data.frame' which can be a bit confusing. These are the classes tibble inherits from which in simple terms means that tibble is a data.frame with a few modifications. Therefore, most of the functions that were used with data.frame can also be used with tibble."
  },
  {
    "objectID": "tidyverse1.html#adding-layers",
    "href": "tidyverse1.html#adding-layers",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.6 Adding layers",
    "text": "4.6 Adding layers\nAs you can see if you just specify the ggplot function with the data and aesthetic mappings, it will just create an empty plot. Let us now add the geom_function for the scatter plot (geom_point) as a layer to the plot: \n\nggplot(data = surveys, mapping = aes(x = weight, y = hindfoot_length)) +\n  geom_point()\n\n\n\n\nYou can customise some of the visualisations of the plot to extract more information from it. For instance, we can add transparency (alpha) to avoid overplotting:\n\nggplot(data = surveys, mapping = aes(x = weight, y = hindfoot_length)) +\n    geom_point(alpha = 0.1)\n\n\n\n\nYou can find a list of aesthetics for each type of plot in the ggplot2 cheat sheet.\nWe can also add colors for all the points:\n\nggplot(data = surveys, mapping = aes(x = weight, y = hindfoot_length)) +\n    geom_point(alpha = 0.1, color = \"blue\")\n\n\n\n\nIf we would like to try other type of plots on the data, the best thing is to save the ggplot into a variable as below:\n\n# Assign plot to a variable\nsurveys_plot &lt;- ggplot(data = surveys, \n                       mapping = aes(x = weight, y = hindfoot_length))\n\n# Draw a scatter plot\nsurveys_plot + \n    geom_point()\n\nNow draw a geom_smooth plot. This plot is good when you need to see if there is any pattern between the two variables being plotted that you would not normally see in a scatter plot due to overplotting.\n\nsurveys_plot +\n    geom_smooth()\n\n\n\n\nRather than seeing each plot separately, sometimes plotting multiple plots on top of each other is a better way. You can add multiple plots as layers on top of each other as follows:\n\nsurveys_plot +\n  geom_point() +\n  geom_smooth()\n\n\n\n\n\nNote\n\nAnything you put in the ggplot() function can be seen by any geom layers that you add (i.e., these are universal plot settings).\nYou can also specify mappings for a given geom independently of the mappings defined globally in the ggplot() function.\nThe + sign used to add new layers must be placed at the end of the line containing the previous layer. If, instead, the + sign is added at the beginning of the line containing the new layer, &gt;ggplot2 will not add the new layer and will return an error message.\n\n\n# This is the correct syntax for adding layers\nsurveys_plot +\n geom_point()\n\n# This will not add the new layer and will return an error message\nsurveys_plot \n + geom_point()\n\n\n\n4.6.1 Challenge\nScatter plots can be useful exploratory tools for small datasets. For data sets with large numbers of observations, such as the surveys data set, overplotting of points can be a limitation of scatter plots. We have already seen how we can visualise data better when we have overplotting with the geom_smooth plot. Another way for handling overplotting is to display the density of the data through contours. As this challenge’s task create a script called plot_density2d.R which loads the file data/portal_data_joined.csv into the variable surveys. It then uses this dataset to plot the weight on the x-axis and hindfoot_length on the y-axis in a geom_density2d plot.\n\nlibrary(tidyverse)\n\n#load the surveys data\nsurveys &lt;- read_csv(\"data/portal_data_joined.csv\")\n\n#attach data and map x and y axes\nsurveys_plot &lt;- ggplot(data = surveys, \n                      mapping = aes(x = weight, y = hindfoot_length))\n#draw geom_density2d\nsurveys_plot +\ngeom_density2d()"
  },
  {
    "objectID": "tidyverse1.html#saveplot",
    "href": "tidyverse1.html#saveplot",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.6 Saving a plot to a file",
    "text": "4.6 Saving a plot to a file\nTo save a plot to file use the ggsave function. If you look at the documentation of ggsave you can see the different arguments the ggsave function takes. Let us save the plot present in the surveys_plot variable into a file called plot_weight_hindfoot_density2d.png into a folder in this project called img_output.\n\n#save plot that you would like to save into a variable\nout_plot &lt;- surveys_plot + geom_density2d()\n#save plot to file\nggsave(filename=\"img_output/plot_weight_hindfoot_density2d.png\", plot=out_plot)\n\n\nNote\n\nYou do not need to save the plot into a variable before saving it to file. If you do not specify the plot argument of the ggsave function, ggsave will take the last plot that you plotted and save it into the filename specified. ::: {.cell}\n\n#save plot to file\nggsave(filename=\"img_output/plot_weight_hindfoot_density2d.png\")\n:::\n\nYou can create folders straight from RStudio from the right bottom pane in the Files section &gt; New Folder icon."
  },
  {
    "objectID": "tidyverse1.html#selecting-columns",
    "href": "tidyverse1.html#selecting-columns",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.7 Selecting columns",
    "text": "4.7 Selecting columns\nTo select columns of a data frame or tibble, use theselect function. The first argument is the data frame or tibble you are working on (in our example it is surveys), and the subsequent arguments are the columns to keep.\n\n#extract species_id, weight, hindfoot_lenth, year and sex columns from surveys dataset.\nselect(surveys, species_id, weight, hindfoot_length, year, sex)\n\nTo select all columns except certain ones, put a - in front of the column to exclude it.\n\n#select all columns of the surveys dataset apart from record_id and species_id columns.\nselect(surveys, -record_id, -species_id)"
  },
  {
    "objectID": "tidyverse1.html#filtering-rows",
    "href": "tidyverse1.html#filtering-rows",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.8 Filtering rows",
    "text": "4.8 Filtering rows\nTo remove rows from a data frame or tibble use the filter function from the dplyr package. The first argument is the data frame or tiblle to perform the filtering on and the next arguments are the conditions on which to keep the rows.\n\n4.8.1 Filtering rows by values\nTo choose rows based on a specific condition, use the filter function as follows:\n\n#keep only the observations of animals collected from 1995 onwards from the surveys dataset.\nfilter(surveys, year &gt;= 1995)\n\nYou can filter on multiple conditions:\n\n#keep only the observations of animals collected from 1995 onwards\n#that are female from the surveys dataset.\nfilter(surveys, year&gt;=1995 & sex==\"F\")\n\n\n\n4.8.2 Remove rows with NA (missing) values\nWhen we were plotting weight against hindfoot_length in the previous section, you must have noticed that we were getting a warning message:\n\n\nWarning: Removed 4048 rows containing missing values (`geom_point()`).\n\n\nThis is because some of the values in the weight and hindfoot_length are NA. NA is short for Not Available and essentially it means that there is no data for that particular index in the table. We also refer to this as missing data. ggplot does not plot the observations that have missing data and outputs the warning above which shows the number of observations that have missing data in the dataset we are plotting. We can filter these rows before we plot them so that ggplot will have all the values for the observations it is plotting and so no warning will be displayed.\nThe is.na function returns TRUE if the value passed to it is NA. Applied to a vector or data frame it will return TRUE or FALSE for each index in the vector or data frame depending on whether the value at each index is missing or not. The ! symbol negates the result, so !is.na can be interpreted as is not NA. See how this can be used in the code below:\n\n#which values of the weight column are missing?\nis.na(surveys$weight)\n\n#which values of the weight column are not missing?\n!is.na(surveys$weight)\n\nNow let us apply the is.na function in dplyr’s filter function to remove the rows that have weight or hindfoot_length as NA from the surveys tibble.\n\nfilter(surveys, \n  !is.na(weight) &  #remove rows that have weight as NA\n  !is.na(hindfoot_length))  #remove rows that have hindfoot_length as NA\n\nAnother way to remove rows that have NA values is by using the drop_na function in the tidyr package. The code above can be replaced by the following code which gives the same answer:\n\ndrop_na(surveys, weight, hindfoot_length)\n\n# A tibble: 30,738 × 13\n   record…¹ month   day  year plot_id speci…² sex   hindf…³ weight genus species\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  \n 1      845     5     6  1978       2 NL      M          32    204 Neot… albigu…\n 2     1164     8     5  1978       2 NL      M          34    199 Neot… albigu…\n 3     1261     9     4  1978       2 NL      M          32    197 Neot… albigu…\n 4     1756     4    29  1979       2 NL      M          33    166 Neot… albigu…\n 5     1818     5    30  1979       2 NL      M          32    184 Neot… albigu…\n 6     1882     7     4  1979       2 NL      M          32    206 Neot… albigu…\n 7     2133    10    25  1979       2 NL      F          33    274 Neot… albigu…\n 8     2184    11    17  1979       2 NL      F          30    186 Neot… albigu…\n 9     2406     1    16  1980       2 NL      F          33    184 Neot… albigu…\n10     3000     5    18  1980       2 NL      F          31     87 Neot… albigu…\n# … with 30,728 more rows, 2 more variables: taxa &lt;chr&gt;, plot_type &lt;chr&gt;, and\n#   abbreviated variable names ¹​record_id, ²​species_id, ³​hindfoot_length\n\n\nUsing drop_na() without specifying any columns will remove all the rows that have NA in any of the columns.\n\ndrop_na(surveys)\n\n# A tibble: 30,676 × 13\n   record…¹ month   day  year plot_id speci…² sex   hindf…³ weight genus species\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  \n 1      845     5     6  1978       2 NL      M          32    204 Neot… albigu…\n 2     1164     8     5  1978       2 NL      M          34    199 Neot… albigu…\n 3     1261     9     4  1978       2 NL      M          32    197 Neot… albigu…\n 4     1756     4    29  1979       2 NL      M          33    166 Neot… albigu…\n 5     1818     5    30  1979       2 NL      M          32    184 Neot… albigu…\n 6     1882     7     4  1979       2 NL      M          32    206 Neot… albigu…\n 7     2133    10    25  1979       2 NL      F          33    274 Neot… albigu…\n 8     2184    11    17  1979       2 NL      F          30    186 Neot… albigu…\n 9     2406     1    16  1980       2 NL      F          33    184 Neot… albigu…\n10     3000     5    18  1980       2 NL      F          31     87 Neot… albigu…\n# … with 30,666 more rows, 2 more variables: taxa &lt;chr&gt;, plot_type &lt;chr&gt;, and\n#   abbreviated variable names ¹​record_id, ²​species_id, ³​hindfoot_length\n\n\nLet us save the results of this in surveys_complete variable which contains only the rows that have all the values in all the columns present and use this for the remaining of the course.\n\nsurveys_complete &lt;- drop_na(surveys)"
  },
  {
    "objectID": "tidyverse1.html#pipes",
    "href": "tidyverse1.html#pipes",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.9 Pipes",
    "text": "4.9 Pipes\nWhat if you want to select and filter at the same time? There are three ways to do this:\n\nuse intermediate steps\nnested functions\npipes\n\nWith intermediate steps, you create a temporary data frame and use that as input to the next function, like this:\n\nsurveys2 &lt;- select(surveys_complete, species_id, weight, hindfoot_length, year, sex)\nsurveys_recent &lt;- filter(surveys2, year &gt;= 1995)\n\nThis is readable, but can clutter up your workspace with lots of objects that you have to name individually. With multiple steps, that can be hard to keep track of.\nYou can also nest functions (i.e., one function inside of another), like this:\n\nsurveys_recent &lt;- filter(\n                    select(surveys_complete, species_id, weight, hindfoot_length, year, sex)\n                    , year &gt;= 1995)\n\nThis is handy, but can be difficult to read if too many functions are nested, as R evaluates the expression from the inside out (in this case, selecting, then filtering).\nThe last option, pipes, are a recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. Pipes in R look like %&gt;% and are made available via the magrittr package, installed automatically with dplyr.\n\nsurveys_complete %&gt;%\n  select(species_id, weight, hindfoot_length, year, sex) %&gt;%\n  filter(year &gt;= 1995)\n\nIn the above code, we use the pipe to send the surveys_complete dataset first through select and then through filter. Some may find it helpful to read the pipe like the word “then”. For instance, in the above example, we took the tibble surveys_complete, then we selected columns species_id, weight, hindfoot_length, yearand sex. We then filtered the rows and only kept the ones that have year &gt;= 1995.\nSince %&gt;% takes the object on its left and passes it as the first argument to the function on its right, we don’t need to explicitly include the data frame/tibble as an argument to the select and filter functions any more. This is one of the biggest advantages of using pipes as it allows us to perform all the operations that we need to do with the need to create useless variables and store useless data. Furthermore, the code is more readable when using pipes. The dplyr functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex manipulations of data frames/tibbles.\nIf we want to create a new object with the transformed data we can assign it a new name as below:\n\nsurveys_recent &lt;- surveys_complete %&gt;%\n                  select(species_id, weight, hindfoot_length, year, sex) %&gt;%\n                  filter(year &gt;= 1995)\n\nsurveys_recent\n\n\n4.9.1 Challenge 1 - pipes\nSubset the surveys_complete data to keep only the species_id, weight, hindfoot_length, year and sex columns and the animals collected on and after 1995. Then plot a scatter plot of weight (x-axis) against hindfoot_length (y-axis) using this transformed dataset. Do all the above using pipes, without creating any variables.\n\nsurveys_complete %&gt;%\n #select columns\n select(species_id, weight, hindfoot_length, year, sex) %&gt;%\n #filter rows\n filter(year &gt;= 1995) %&gt;%\n #plot transformed data\n ggplot(mapping=aes(x=weight, y=hindfoot_length)) +\n   geom_point()\n\n\n\n4.9.2 Challenge 2 - plotting subset with different colour\nPlot all the animals in the surveys_complete dataset as weight (x-axis) against hindfoot_length (y-axis). Use the dataset created above which contains only the animals that were collected on and after 1995 and highlight these points in red in the plot.\n\nsurvey_recent &lt;- surveys_complete %&gt;%\n                 select(species_id, weight, hindfoot_length, year, sex) %&gt;%\n                 filter(year &gt;= 1995)\n\nggplot(mapping=aes(x=weight, y=hindfoot_length)) +\n geom_point(data=surveys_complete) +\n geom_point(data=survey_recent, color=\"red\")\n\nNote: In the example above we did not specify the data argument in the ggplot function because the arguments in the ggplot function should be common throughout the whole plot. In this case we specified the respective data as separate layers in 2 different geom_point plots; the first plot is the data with all the animals in surveys_complete (points in black), the second plot is layered on top of the first plot which is a subset of the surveys_complete dataset (points in red).\n\n\n\n\n\n\n1. H Wickham, G. G., M Çetinkaya-Rundel. R for data science. (O’Reily Media, 2023)."
  },
  {
    "objectID": "tidyverse1.html#footnotes",
    "href": "tidyverse1.html#footnotes",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "",
    "text": "https://readr.tidyverse.org/\n\n↩︎"
  },
  {
    "objectID": "tidyverse1.html#data-exploration-workflow",
    "href": "tidyverse1.html#data-exploration-workflow",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.1 Data exploration workflow",
    "text": "4.1 Data exploration workflow\nWhen you are working on a project that requires data analysis, you will normally need to perform the following steps:\n\n\n\nFigure 4.1: A data science workflow1\n\n\nTo understand better the workflow1 in the illustration above, let us go over each stage to see what each step entails:\n\nThe first step in working with data is to first import your data into R. This connects the external file/database to your project in R.\nCleaning or tidying the data will follow, which involves making sure that the data is consistent and that each row in the dataset is an observation and each column is a variable.\ne.g. In the surveys data frame the month column specifies months as an integer from 1 to 12. The dataset would have inconsistent data if there was a record in the dataset that had a month specified by name, e.g. September rather than 9. A month of 0 or any other number that is not in the range 1 to 12 would have also made the dataset inconsistent. Another common problem is capitalisation; the same word in the same column can be written with capitals or without; e.g. Bird or bird in the same taxa column is inconsistent data. During the tidying stage it is important to make the dataset consistent as much as possible so that you can focus on the questions you are trying to solve in your analysis.\n\nOnce the dataset is tidy, we move to the transformation stage. To be able to transform your data you need to plan in advance what analyses you would like to perform on the dataset and what plots you would like to create. In this way, you are able to plan ahead what variables/columns you will be using from the dataset, what additional variables you will need to create and what variables you will not be using so that you can keep only the columns in the dataset that are relevant for your analyses. By the end of the transformation process you will have a dataset that is focused for your analyses and you can move on to the main exploratory mechanisms of this workflow which are visualisation and modelling. These two stages complement each other and when exploring your data you normally repeat these two stages several times.\n\nVisualising data is a powerful way to explore your data. Furthermore it helps you understand if there is any pattern in the data.\n\nModelling the data involves applying statistics or other mathematical or computational models on your data to explore if there are correlations or patterns in the dataset to help you answer the scientific question you are trying to solve.\n\nThe last step in the data exploration workflow is to communicate your results. This is very important as you will need to be able to communicate your results to others to have a successful project.\n\nAll these stages in the data exploration workflow can be achieved by programming in R. In these R practicals we will not look into the Model and Communicate stages of the workflow in this course.\nIn the next sections we will be looking at the import, tidy, transform and visualise stages of the data exploration workflow by using one of the most popular packages in data science in R; Tidyverse."
  },
  {
    "objectID": "tidyverse1.html#packages",
    "href": "tidyverse1.html#packages",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.2 Packages",
    "text": "4.2 Packages\nSo far we have learnt how to use R with R’s in-built functionality that we will refer to as R base. There is a way, however, to extend this functionality by using external functions through packages. Packages in R are basically sets of additional functions that let you do more stuff. The functions we’ve been using so far, like str() or head(), come built into R; packages give you access to more of them.\n\n\n4.2.1 Tidyverse\nThe package that we will be using in this course is called tidyverse. It is an “umbrella-package” that contains several packages useful for data manipulation and visualisation which work well together such as readr, tidyr, dplyr, ggplot2, tibble, etc…\n\nTidyverse is a recent package (launched in 2016) when compared to R base (stable version in 2000), thus you will still come across R resources that do not use tidyverse. However, since its’ release, tidyverse has been increasing in popularity throughout the R programming community and it is now very popular in Data Science as it was designed with the aim to help Data Scientists perform their tasks more efficiently.\nSome of the main advantages of tidyverse over R base are:\n\nEasier to read \n\nBracket subsetting is handy, but it can be cumbersome and difficult to read, especially for complicated operations.\n\n\ne.g. Get only the rows that have species as albigula surveyed in the year 1977.\n\n\n# R Base\nsurveys[surveys$species==\"albigula\" &\n        surveys$year==1977, ]\n\n# tidyverse\nfilter(surveys, species==\"albigula\" & year==1977)\n\n\nFaster\n\nUsing tidyverse is up to 10x faster1 when compared to the corresponding base R base functions.\n\nStrings are not converted to factor\n\nWe have seen in our previous lesson that when building or importing a data frame, the columns that contain characters (i.e., text) are coerced (=converted) into the factor data type. We had to set stringsAsFactors to FALSE to avoid this hidden argument to convert our data type. With tidyverse, this does not happen.\n\n\n\n4.2.2 Installing and loading packages\nBefore using a package for the first time you will need to install it on your machine, and then you should import it in every subsequent R session when you need it. To install a package in R on your machine you need to use the install.packages function. To install the tidyverse package type the following straight into the console:\n\n#install the tidyverse package\ninstall.packages(\"tidyverse\")\n\nIt is better to install packages straight from the console then from your script as there’s no need to re-install packages every time you run the script.\nThen, to load the package type:\n\n## load the tidyverse package\nlibrary(tidyverse)"
  },
  {
    "objectID": "tidyverse1.html#importingreading-data-from-files",
    "href": "tidyverse1.html#importingreading-data-from-files",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.3 Importing/Reading data from files",
    "text": "4.3 Importing/Reading data from files\nAfter loading the tidyverse package in R we are now able to use its’ functions. We will start working through the data exploration workflow by first importing data into R. To import the data into R as before, we will now use the read_csv function, from the tidyverse package readr, instead of using read.csv from R base. The readr package contains functions to read tabular data into R. Let us read in the same file we used before using tidyverse this time:\n\nsurveys &lt;- read_csv(\"data/portal_data_joined.csv\")"
  },
  {
    "objectID": "tidyverse1.html#visualising-data-in-r",
    "href": "tidyverse1.html#visualising-data-in-r",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.5 Visualising data in R",
    "text": "4.5 Visualising data in R\nAfter inspecting the surveys dataset in R, the data looks tidy and we are happy with its format, so let us start understanding better our data by visualising it. ggplot2 is the visualisation package in tidyverse and we will be using this to create some plots. ggplot2 is a very popular package used for plotting mainly due to its simple way to create plots from tabular data.\nTo create a plot, we will use the following basic template.\nggplot(data = &lt;DATA&gt;, mapping = aes(&lt;MAPPINGS&gt;)) +  &lt;GEOM_FUNCTION&gt;()\nAs you can see there are 3 main elements that you need to create a plot:\nThe ggplot function takes 2 arguments:\n\ndata: This is the data frame to attach to the plot. The data frame must contain the variables to plot as columns and the rows must contain the observations that you need to plot.\nmapping: Aesthetic mappings describe how variables in the data are mapped to visual properties of the plot.\n\nUsing the ggplot function on its own will not plot anything. We need to add a geom_function as a layer. Layers are added to plots by using +. They are added on top of the other previous layers that might be present.\n\ngeom_function: This specifies the type of plot would you like to plot. The greatest advantage of this is that you can easily change the plot type by just changing the geom_function and keeping everything else the same. You can see a whole list of plots that you can plot here.\n\nLet us practice this on our surveys dataset. We would like to create a scatter plot with weight on the x-axis, hindfoot_length on the y-axis\n\nggplot(data = surveys, mapping = aes(x = weight, y = hindfoot_length))\n\n\n\n\n\n4.5.1 Adding layers\nAs you can see if you just specify the ggplot function with the data and aesthetic mappings, it will just create an empty plot. Let us now add the geom_function for the scatter plot (geom_point) as a layer to the plot: \n\nggplot(data = surveys, mapping = aes(x = weight, y = hindfoot_length)) +\n  geom_point()\n\n\n\n\nYou can customise some of the visualisations of the plot to extract more information from it. For instance, we can add transparency (alpha) to avoid overplotting:\n\nggplot(data = surveys, mapping = aes(x = weight, y = hindfoot_length)) +\n    geom_point(alpha = 0.1)\n\n\n\n\nYou can find a list of aesthetics for each type of plot in the ggplot2 cheat sheet.\nWe can also add colors for all the points:\n\nggplot(data = surveys, mapping = aes(x = weight, y = hindfoot_length)) +\n    geom_point(alpha = 0.1, color = \"blue\")\n\n\n\n\nIf we would like to try other type of plots on the data, the best thing is to save the ggplot into a variable as below:\n\n# Assign plot to a variable\nsurveys_plot &lt;- ggplot(data = surveys, \n                       mapping = aes(x = weight, y = hindfoot_length))\n\n# Draw a scatter plot\nsurveys_plot + \n    geom_point()\n\nNow draw a geom_smooth plot. This plot is good when you need to see if there is any pattern between the two variables being plotted that you would not normally see in a scatter plot due to overplotting.\n\nsurveys_plot +\n    geom_smooth()\n\n\n\n\nRather than seeing each plot separately, sometimes plotting multiple plots on top of each other is a better way. You can add multiple plots as layers on top of each other as follows:\n\nsurveys_plot +\n  geom_point() +\n  geom_smooth()\n\n\n\n\n\n\n\n\n\n\nNote\n\n\n\n\nAnything you put in the ggplot() function can be seen by any geom layers that you add (i.e., these are universal plot settings).\nYou can also specify mappings for a given geom independently of the mappings defined globally in the ggplot() function.\nThe + sign used to add new layers must be placed at the end of the line containing the previous layer. If, instead, the + sign is added at the beginning of the line containing the new layer, &gt;ggplot2 will not add the new layer and will return an error message.\n\n\n# This is the correct syntax for adding layers\nsurveys_plot +\n  geom_point()\n\n# This will not add the new layer and will return an error message\nsurveys_plot \n  + geom_point()\n\n\n\n\n\n\n\n\n\nExercise 7\n\n\n\nLevel: \nScatter plots can be useful exploratory tools for small datasets. For data sets with large numbers of observations, such as the surveys data set, overplotting of points can be a limitation of scatter plots. We have already seen how we can visualise data better when we have overplotting with the geom_smooth plot. Another way for handling overplotting is to display the density of the data through contours. As this challenge’s task create a script called plot_density2d.R which loads the file data/portal_data_joined.csv into the variable surveys. It then uses this dataset to plot the weight on the x-axis and hindfoot_length on the y-axis in a geom_density2d plot.\n\n\n\n\n\n\nSolution for Exercise 7\n\n\n\n\n\n\nlibrary(tidyverse)\n\n#load the surveys data\nsurveys &lt;- read_csv(\"data/portal_data_joined.csv\")\n \n#attach data and map x and y axes\nsurveys_plot &lt;- ggplot(data = surveys, \n                       mapping = aes(x = weight, y = hindfoot_length))\n#draw geom_density2d\nsurveys_plot +\n  geom_density2d()\n\n\n\n\n\n\n\n\n4.5.2 Saving a plot to a file\nTo save a plot to file use the ggsave function. If you look at the documentation of ggsave you can see the different arguments the ggsave function takes. Let us save the plot present in the surveys_plot variable into a file called plot_weight_hindfoot_density2d.png into a folder in this project called img_output.\n\n#save plot that you would like to save into a variable\nout_plot &lt;- surveys_plot + geom_density2d()\n#save plot to file\nggsave(filename=\"img_output/plot_weight_hindfoot_density2d.png\", plot=out_plot)\n\n\n\n\n\n\n\nNote\n\n\n\n\nYou do not need to save the plot into a variable before saving it to file. If you do not specify the plot argument of the ggsave function, ggsave will take the last plot that you plotted and save it into the filename specified.\n\n\n#save plot to file\nggsave(filename=\"img_output/plot_weight_hindfoot_density2d.png\")\n\n\nYou can create folders straight from RStudio from the right bottom pane in the Files section &gt; New Folder icon."
  },
  {
    "objectID": "tidyverse1.html#transforming-data---dplyr",
    "href": "tidyverse1.html#transforming-data---dplyr",
    "title": "4  Data manipulation and visualisation with tidyverse",
    "section": "4.6 Transforming data - dplyr",
    "text": "4.6 Transforming data - dplyr\nIn most of the cases you will need to change the format of your dataset because it will not be in the right format that you will need to plot or analyse the data. tidyverse has a package called dplyr which contains functions that help you to select columns/rows, sort, combine and perform other data types of data transformations. In the next sections we will look at different ways to transform our dataset. Now that we already know the basics of visualising data with ggplot we will also learn how to visualise other plots with the transformed dataset as we go along.\n\nTo learn more about dplyr please look at the following resources:\n\ndplyr cheat sheet\ndplyr documentation\n\nIf you find these resources difficult to understand, return to these after completing the course.\n\n\n4.6.1 Selecting columns\nTo select columns of a data frame or tibble, use theselect function. The first argument is the data frame or tibble you are working on (in our example it is surveys), and the subsequent arguments are the columns to keep.\n\n#extract species_id, weight, hindfoot_length, year and sex columns from surveys dataset.\nselect(surveys, species_id, weight, hindfoot_length, year, sex)\n\nTo select all columns except certain ones, put a - in front of the column to exclude it.\n\n#select all columns of the surveys dataset apart from record_id and species_id columns.\nselect(surveys, -record_id, -species_id)\n\n\n\n4.6.2 Filtering rows\nTo remove rows from a data frame or tibble use the filter function from the dplyr package. The first argument is the data frame or tibble to perform the filtering on and the next arguments are the conditions on which to keep the rows.\n\n4.6.2.1 Filtering rows by values\nTo choose rows based on a specific condition, use the filter function as follows:\n\n#keep only the observations of animals collected from 1995 onwards from the surveys dataset.\nfilter(surveys, year &gt;= 1995)\n\nYou can filter on multiple conditions:\n\n#keep only the observations of animals collected from 1995 onwards\n#that are female from the surveys dataset.\nfilter(surveys, year&gt;=1995 & sex==\"F\")\n\n\n\n4.6.2.2 Remove rows with NA (missing) values\nWhen we were plotting weight against hindfoot_length in the previous section, you must have noticed that we were getting a warning message:\n\n\nWarning: Removed 4048 rows containing missing values (`geom_point()`).\n\n\nThis is because some of the values in the weight and hindfoot_length are NA. NA is short for Not Available and essentially it means that there is no data for that particular index in the table. We also refer to this as missing data. ggplot does not plot the observations that have missing data and outputs the warning above which shows the number of observations that have missing data in the dataset we are plotting. We can filter these rows before we plot them so that ggplot will have all the values for the observations it is plotting and so no warning will be displayed.\nThe is.na function returns TRUE if the value passed to it is NA. Applied to a vector or data frame it will return TRUE or FALSE for each index in the vector or data frame depending on whether the value at each index is missing or not. The ! symbol negates the result, so !is.na can be interpreted as is not NA. See how this can be used in the code below:\n\n#which values of the weight column are missing?\nis.na(surveys$weight)\n\n#which values of the weight column are not missing?\n!is.na(surveys$weight)\n\nNow let us apply the is.na function in dplyr’s filter function to remove the rows that have weight or hindfoot_length as NA from the surveys tibble.\n\nfilter(surveys, \n  !is.na(weight) &  #remove rows that have weight as NA\n  !is.na(hindfoot_length))  #remove rows that have hindfoot_length as NA\n\nAnother way to remove rows that have NA values is by using the drop_na function in the tidyr package. The code above can be replaced by the following code which gives the same answer:\n\ndrop_na(surveys, weight, hindfoot_length)\n\n# A tibble: 30,738 × 13\n   record…¹ month   day  year plot_id speci…² sex   hindf…³ weight genus species\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  \n 1      845     5     6  1978       2 NL      M          32    204 Neot… albigu…\n 2     1164     8     5  1978       2 NL      M          34    199 Neot… albigu…\n 3     1261     9     4  1978       2 NL      M          32    197 Neot… albigu…\n 4     1756     4    29  1979       2 NL      M          33    166 Neot… albigu…\n 5     1818     5    30  1979       2 NL      M          32    184 Neot… albigu…\n 6     1882     7     4  1979       2 NL      M          32    206 Neot… albigu…\n 7     2133    10    25  1979       2 NL      F          33    274 Neot… albigu…\n 8     2184    11    17  1979       2 NL      F          30    186 Neot… albigu…\n 9     2406     1    16  1980       2 NL      F          33    184 Neot… albigu…\n10     3000     5    18  1980       2 NL      F          31     87 Neot… albigu…\n# … with 30,728 more rows, 2 more variables: taxa &lt;chr&gt;, plot_type &lt;chr&gt;, and\n#   abbreviated variable names ¹​record_id, ²​species_id, ³​hindfoot_length\n\n\nUsing drop_na() without specifying any columns will remove all the rows that have NA in any of the columns.\n\ndrop_na(surveys)\n\n# A tibble: 30,676 × 13\n   record…¹ month   day  year plot_id speci…² sex   hindf…³ weight genus species\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  \n 1      845     5     6  1978       2 NL      M          32    204 Neot… albigu…\n 2     1164     8     5  1978       2 NL      M          34    199 Neot… albigu…\n 3     1261     9     4  1978       2 NL      M          32    197 Neot… albigu…\n 4     1756     4    29  1979       2 NL      M          33    166 Neot… albigu…\n 5     1818     5    30  1979       2 NL      M          32    184 Neot… albigu…\n 6     1882     7     4  1979       2 NL      M          32    206 Neot… albigu…\n 7     2133    10    25  1979       2 NL      F          33    274 Neot… albigu…\n 8     2184    11    17  1979       2 NL      F          30    186 Neot… albigu…\n 9     2406     1    16  1980       2 NL      F          33    184 Neot… albigu…\n10     3000     5    18  1980       2 NL      F          31     87 Neot… albigu…\n# … with 30,666 more rows, 2 more variables: taxa &lt;chr&gt;, plot_type &lt;chr&gt;, and\n#   abbreviated variable names ¹​record_id, ²​species_id, ³​hindfoot_length\n\n\nLet us save the results of this in surveys_complete variable which contains only the rows that have all the values in all the columns present and use this for the remaining of the course.\n\nsurveys_complete &lt;- drop_na(surveys)\n\n\n\n\n4.6.3 Pipes\nWhat if you want to select and filter at the same time? There are three ways to do this:\n\nuse intermediate steps\nnested functions\npipes\n\nWith intermediate steps, you create a temporary data frame and use that as input to the next function, like this:\n\nsurveys2 &lt;- select(surveys_complete, species_id, weight, hindfoot_length, year, sex)\nsurveys_recent &lt;- filter(surveys2, year &gt;= 1995)\n\nThis is readable, but can clutter up your workspace with lots of objects that you have to name individually. With multiple steps, that can be hard to keep track of.\nYou can also nest functions (i.e., one function inside of another), like this:\n\nsurveys_recent &lt;- filter(\n                    select(surveys_complete, species_id, weight, hindfoot_length, year, sex)\n                    , year &gt;= 1995)\n\nThis is handy, but can be difficult to read if too many functions are nested, as R evaluates the expression from the inside out (in this case, selecting, then filtering).\nThe last option, pipes, are a recent addition to R. Pipes let you take the output of one function and send it directly to the next, which is useful when you need to do many things to the same dataset. Pipes in R look like %&gt;% and are made available via the magrittr package, installed automatically with dplyr.\n\nsurveys_complete %&gt;%\n  select(species_id, weight, hindfoot_length, year, sex) %&gt;%\n  filter(year &gt;= 1995)\n\nIn the above code, we use the pipe to send the surveys_complete dataset first through select and then through filter. Some may find it helpful to read the pipe like the word “then”. For instance, in the above example, we took the tibble surveys_complete, then we selected columns species_id, weight, hindfoot_length, yearand sex. We then filtered the rows and only kept the ones that have year &gt;= 1995.\nSince %&gt;% takes the object on its left and passes it as the first argument to the function on its right, we don’t need to explicitly include the data frame/tibble as an argument to the select and filter functions any more. This is one of the biggest advantages of using pipes as it allows us to perform all the operations that we need to do with the need to create useless variables and store useless data. Furthermore, the code is more readable when using pipes. The dplyr functions by themselves are somewhat simple, but by combining them into linear workflows with the pipe, we can accomplish more complex manipulations of data frames/tibbles.\nIf we want to create a new object with the transformed data we can assign it a new name as below:\n\nsurveys_recent &lt;- surveys_complete %&gt;%\n                  select(species_id, weight, hindfoot_length, year, sex) %&gt;%\n                  filter(year &gt;= 1995)\n\nsurveys_recent\n\n\n\n\n\n\n\nExercise 8\n\n\n\nLevel: \nSubset the surveys_complete data to keep only the species_id, weight, hindfoot_length, year and sex columns and the animals collected on and after 1995. Then plot a scatter plot of weight (x-axis) against hindfoot_length (y-axis) using this transformed dataset. Do all the above using pipes, without creating any variables.\n\n\n\n\n\n\nSolution for Exercise 8\n\n\n\n\n\n\nsurveys_complete %&gt;%\n  #select columns\n  select(species_id, weight, hindfoot_length, year, sex) %&gt;%\n  #filter rows\n  filter(year &gt;= 1995) %&gt;%\n  #plot transformed data\n  ggplot(mapping=aes(x=weight, y=hindfoot_length)) +\n    geom_point()\n\n\n\n\n\n\n\n\n\n\n\n\nExercise 9\n\n\n\nLevel: \nPlot all the animals in the surveys_complete dataset as weight (x-axis) against hindfoot_length (y-axis). Use the dataset created above which contains only the animals that were collected on and after 1995 and highlight these points in red in the plot.\n\n\n\n\n\n\nSolution for Exercise 9\n\n\n\n\n\n\nsurvey_recent &lt;- surveys_complete %&gt;%\n                  select(species_id, weight, hindfoot_length, year, sex) %&gt;%\n                  filter(year &gt;= 1995)\n\nggplot(mapping=aes(x=weight, y=hindfoot_length)) +\n  geom_point(data=surveys_complete) +\n  geom_point(data=survey_recent, color=\"red\")\n\n\n\n\n\n\n\nNote\n\n\n\nIn the example above we did not specify the data argument in the ggplot function because the arguments in the ggplot function should be common throughout the whole plot. In this case we specified the respective data as separate layers in 2 different geom_point plots; the first plot is the data with all the animals in surveys_complete (points in black), the second plot is layered on top of the first plot which is a subset of the surveys_complete dataset (points in red).\n\n\n\n\n\n\n\n\n\n4.6.4 Creating new columns\nFrequently you’ll want to create new columns based on the values in existing columns, for example to do unit conversions, or to find the ratio of values in two columns. For this we’ll use the mutate function.\nTo create a new column of weight in kg:\n\nsurveys_complete %&gt;%\n  mutate(weight_kg = weight / 1000)\n\n# A tibble: 30,676 × 14\n   record…¹ month   day  year plot_id speci…² sex   hindf…³ weight genus species\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  \n 1      845     5     6  1978       2 NL      M          32    204 Neot… albigu…\n 2     1164     8     5  1978       2 NL      M          34    199 Neot… albigu…\n 3     1261     9     4  1978       2 NL      M          32    197 Neot… albigu…\n 4     1756     4    29  1979       2 NL      M          33    166 Neot… albigu…\n 5     1818     5    30  1979       2 NL      M          32    184 Neot… albigu…\n 6     1882     7     4  1979       2 NL      M          32    206 Neot… albigu…\n 7     2133    10    25  1979       2 NL      F          33    274 Neot… albigu…\n 8     2184    11    17  1979       2 NL      F          30    186 Neot… albigu…\n 9     2406     1    16  1980       2 NL      F          33    184 Neot… albigu…\n10     3000     5    18  1980       2 NL      F          31     87 Neot… albigu…\n# … with 30,666 more rows, 3 more variables: taxa &lt;chr&gt;, plot_type &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, and abbreviated variable names ¹​record_id, ²​species_id,\n#   ³​hindfoot_length\n\n\nYou can also create a second new column based on the first new column within the same call of mutate():\n\nsurveys_complete %&gt;%\n  mutate(weight_kg = weight / 1000,\n         weight_kg2 = weight_kg * 2)\n\n# A tibble: 30,676 × 15\n   record…¹ month   day  year plot_id speci…² sex   hindf…³ weight genus species\n      &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt; &lt;dbl&gt;   &lt;dbl&gt; &lt;chr&gt;   &lt;chr&gt;   &lt;dbl&gt;  &lt;dbl&gt; &lt;chr&gt; &lt;chr&gt;  \n 1      845     5     6  1978       2 NL      M          32    204 Neot… albigu…\n 2     1164     8     5  1978       2 NL      M          34    199 Neot… albigu…\n 3     1261     9     4  1978       2 NL      M          32    197 Neot… albigu…\n 4     1756     4    29  1979       2 NL      M          33    166 Neot… albigu…\n 5     1818     5    30  1979       2 NL      M          32    184 Neot… albigu…\n 6     1882     7     4  1979       2 NL      M          32    206 Neot… albigu…\n 7     2133    10    25  1979       2 NL      F          33    274 Neot… albigu…\n 8     2184    11    17  1979       2 NL      F          30    186 Neot… albigu…\n 9     2406     1    16  1980       2 NL      F          33    184 Neot… albigu…\n10     3000     5    18  1980       2 NL      F          31     87 Neot… albigu…\n# … with 30,666 more rows, 4 more variables: taxa &lt;chr&gt;, plot_type &lt;chr&gt;,\n#   weight_kg &lt;dbl&gt;, weight_kg2 &lt;dbl&gt;, and abbreviated variable names\n#   ¹​record_id, ²​species_id, ³​hindfoot_length\n\n\nThere are other ways on how to create new columns. Refer to the dplyr cheat sheet Make New Variables section.\n\n\n\n\n\n\nExercise 10\n\n\n\nLevel: \nUsing the surveys_complete dataset, create a boxplot for each year on the x-axis and weight in kg on the y-axis. Filter the dataset so that only recent observations (from 1995 onwards) are used. As before try to do all the operations using pipes, without creating variables.\n\n\n\n\n\n\nSolution for Exercise 10\n\n\n\n\n\nYour first attempt would be to use the code we used before to subset the surveys_complete dataset, but also adding the mutate function to add a new weight_kg column. Further more you will need to also add the ggplot function to draw a boxplot:\n\nsurveys_complete %&gt;%\n  #add weight_kg column\n  mutate(weight_kg = weight / 1000) %&gt;%\n  #filter rows\n  filter(year &gt;= 1995) %&gt;%\n  #plot transformed data\n  ggplot(mapping=aes(x=year, y=weight_kg)) +\n    geom_boxplot()\n\nWarning: Continuous x aesthetic\nℹ did you forget `aes(group = ...)`?\n\n\n\n\n\nYou might notice that this code produces a warning message about the continuous data type of the x-axis and also creates a box plot with one single box and whisker averaged over all the years on the x-axis, rather than one for each year in the dataset as requested. As shown in the ggplot2 cheat sheet, box plots display a discrete variable on the x-axis and a continuous variable on the y-axis. At the moment year is treated as a continuous variable since its data type is double (you can see this from the tibble). To fix this, we need to convert the data type of the year column to a categorical one (factor) so that each year can be plotted as a separate box and whisker.\n\nsurveys_complete %&gt;%\n  #add weight_kg column\n  mutate(weight_kg = weight / 1000) %&gt;%\n  #filter rows\n  filter(year &gt;= 1995) %&gt;%\n  #convert the year column to a factor\n  mutate(year=as.factor(year)) %&gt;%\n  #plot transformed data\n  ggplot(mapping=aes(x=year, y=weight_kg)) +\n    geom_boxplot()\n\n\n\n\nNotice that since we need to keep only observations that have been observed from 1995 onwards, we need to convert the year column to a factor after we filter the rows, as otherwise the row filtering operation will not be possible. This is because the new year column of type factor does not have any ordering in its categories so performing year &gt;= 1995 would not be possible.\n\n\n\n\n\n\nNote\n\n\n\nAs mentioned the boxplot is used to visualise the distribution of a continuous variable. In the example above we displayed the distribution of weight over the different years. The figure below illustrates the different components of the boxplot. The bottom line of the box represents the 25th quantile, middle line the 50th quantile (or median) and the top line of the box is the 75th quantile. The whiskers can be thought of as defining the boundary of the confidence intervals of the distribution. The dots outside these whiskers are the outliers.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n1. H Wickham, G. G., M Çetinkaya-Rundel. R for data science. (O’Reily Media, 2023)."
  }
]